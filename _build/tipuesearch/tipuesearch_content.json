{
    "pages": [
        {
            "tags": "", 
            "text": "To add user info, please first read the Site development guide . MyHDL users can add their info under the /users directory.  If a single page\nis sufficient, put the info in a <username>.md file. Otherwise, create a\ndirectory <username> and add an index.md and other pages there. \nIn the latter case, use index.md as the main entry point\nfor your info, it works best for nice urls. File and directory names map to urls, so avoid whitespace and use\nall lowercase names. There are some placeholder files and directories to show how it works. You can\nstart by picking a placeholder and rename it. A typical layout for your content pages would be article . If you don't need a\nsidebar, use simple_article . If you need a wider area for the text, use wide_article . Be sure to add the page or folder name as a list item entry in the content field of the users/index .", 
            "title": "How to add user info", 
            "url": "/user-guide.html"
        }, 
        {
            "tags": "", 
            "text": "Website development This website is developed collaboratively by the MyHDL\ncommunity. It is developed using the Urubu software. Read more » Theme The theme of this website uses the Bootstrap framework.  It is based on the Flatly theme, provided by Bootswatch . License The content on this website is licensed under the CC-BY-SA License . Terms of Use", 
            "title": "Info", 
            "url": "/info.html"
        }, 
        {
            "tags": "", 
            "text": "This guide is intended for all those who want to help with the development of\nthis site. The site is developed using Urubu . Please consult the Urubu website to\ninstall the software and get an overview of how it works. As a content\ncontributor, you don't need all the details about templating and so on: the\nmain task will be editing content in Markdown format. The site is being developed on GitHub in the MyHDL website repository .  You can\ncontribute through pull requests, or I will consider to give you direct access\nto the repository. Publishing the content is automatic after a push, but it may take up to ten\nminutes before the edits are online. The website content is pulled from the\nrepo, so make sure to commit the built website also. This site has been migrated from on old site. Not all content has been\nmigrated, but that can still be done if desired. You can visit the old version of the site under old.myhdl.org .    The orginal\ncontent has been checked in under _ori . There is a convert.py script that\ncan help to convert the original dokuwiki format to Markdown. It is far from\ncomprehensive, but should provide a good starting point.", 
            "title": "Site development guide", 
            "url": "/site-development.html"
        }, 
        {
            "tags": "", 
            "text": "This site is being migrated from myhdl.org .  This guide is intended for all those who want to\nhelp with the migration. The site is being migrated from a dokuwiki site to an Urubu site. Please\nconsult the Urubu website to install the software and get an overview of how\nit works. As a content contributor, you don't need all the details about\ntemplating and so on: the main task will be editing content in Markdown format. The site is being developed on BitBucket in the MyHDL website repository . The\norginal code from myhdl.org is checked in under _ori . There is a convert.py script that can help to convert the original dokuwiki format to Markdown. It is\nfar from comprehensive, but should provide a good starting point. You can contribute through pull requests, or I will consider to give you direct\naccess to the repository. Publishing the content is automatic after a push, but it may take up to ten\nminutes before the edits are online. The website content is pulled from\nthe repo, so make sure to commit the built website also.", 
            "title": "Migration guide", 
            "url": "/migration.html"
        }, 
        {
            "tags": "", 
            "text": "", 
            "title": "Search", 
            "url": "/search.html"
        }, 
        {
            "tags": "", 
            "text": "Attribution These Terms of Use are based on the Terms of Use of\nWikipedia . Information for text contributors All users contributing to myhdl.org are required to grant broad permissions\nto the general public to re-distribute and re-use their contributions freely,\nas long as the use is attributed and the same freedom to re-use and\nre-distribute applies to any derivative works. Therefore, for any text you hold\nthe copyright to, by submitting it, you agree to license it under the Creative\nCommons Attribution/Share-Alike License 3.0 (Unported) . Please note that\nthis license does allow commercial uses of your contributions, as long as\nsuch uses are compliant with the terms. As an author, you agree to be attributed in any of the following fashions: through a hyperlink (where possible) or URL to the article or articles you\ncontributed to, through a hyperlink (where possible) or URL to an alternative, stable online\ncopy which is freely accessible, which conforms with the license, and which\nprovides credit to the authors in a manner equivalent to the credit given on\nthis website through a list of all authors. (Any list of authors may be filtered to\nexclude very small or irrelevant contributions.) Information for re-users To re-use content from myhdl.org , please follow the guidelines below: Attribution: To re-distribute a text page in any form, provide credit to the\nauthors either by including a) a hyperlink (where possible) or URL to the\npage or pages you are re-using, b) a hyperlink (where possible) or URL to an\nalternative, stable online copy which is freely accessible, which conforms\nwith the license, and which provides credit to the authors in a manner\nequivalent to the credit given on this website, or c) a list of all authors. Copyleft/Share Alike: If you make modifications or additions to the page you\nre-use, you must license them under the Creative Commons\nAttribution-Share-Alike License 3.0 or later. Indicate changes: If you make modifications or additions, you must indicate\nin a reasonable fashion that the original work has been modified. If you are\nre-using the page in a wiki, for example, indicating this in the page history\nis sufficient. Licensing notice: Each copy or modified version that you distribute must\ninclude a licensing notice stating that the work is released under CC-BY-SA\nand either a) a hyperlink or URL to the text of the license or b) a copy of\nthe license. For this purpose, a suitable URL is http://creativecommons.org/licenses/by-sa/3.0/ . For further information, please refer to the legal code of the CC-BY-SA License .", 
            "title": "Terms of Use", 
            "url": "/terms-of-use.html"
        }, 
        {
            "tags": "", 
            "text": "Design hardware with Python MyHDL turns Python into a hardware description and verification\nlanguage, providing hardware engineers with the power of the Python ecosystem. Integrates seamlessly MyHDL designs can be converted to Verilog or VHDL automatically, and\nimplemented using a standard tool flow. Silicon proven Many MyHDL designs have been implemented in ASICs and FPGAs,\nincluding some high volume applications. Open source MyHDL is an open source, pure Python package. Install with pip and enjoy the Python ecosystem immediately. Visit the project on Github. Release news 31-May-2019 MyHDL 0.11.0 released General news 18-Mar-2015 Python3 Support 18-Mar-2014 A makeover for myhdl.org 24-Apr-2013 Follow MyHDL on twitter! Tweets Tweets by @MyHDL", 
            "title": "MyHDL", 
            "url": "/index.html"
        }, 
        {
            "tags": "", 
            "text": "Introduction There are many good reasons to consider MyHDL. However, to use it\neffectively, it is important to have realistic expectations. The easiest way to\nachieve this is perhaps to describe what MyHDL is not . It does not turn arbitrary Python into silicon Arbitrary Python into silicon, that sounds like a dream, right? And it is :-)\nDon't expect this from MyHDL. To convert MyHDL code into hardware, you will have to learn about synthesis , and especially about\nthe modeling constraints that it imposes. These constraints are significant,\nand therefore synthesizable code may be suprisingly low-level to newcomers. Not a radically new approach The mainstream Hardware Description Languages are Verilog and VHDL. MyHDL was\nnot created because these languages do everything wrong. Quite the contrary. According to the analysis of MyHDL's creator, the promise of HDL-based design\nhas not been fulfilled despite the fact that Verilog and VHDL do many things\nright. MyHDL tries to lower the barrier to entry and improve on certain\nlanguage features that make the task more difficult than necessary. The most important MyHDL design choice is to implement it as a Python library\ninstead of as a separate language. This makes it available to a much broader\npublic, and opens the way to modern software development techniques such as\ntest-driven design (TDD). However, fundamentally MyHDL is based on the same event-driven paradigm as\nVerilog and VHDL. This has proven to be the winning solution for HDL design. It is not a synthesis tool MyHDL alone is not sufficient to convert code into a hardware implementation.\nIn other words, it is not a synthesis tool. However, MyHDL contains a convertor tool that you can use to convert\nsynthesizable MyHDL code into equivalent Verilog or VHDL code. From there on,\nyou can use standard synthesis tools to get to an implementation. Synthesis\ntools are available from EDA vendors and FPGA vendors. Some synthesis tools\nfrom FPGA vendors are cheap or even free. Although the convertor in MyHDL is not a synthesis tool, it automates a number\nof tasks which are harder to do in Verilog or VHDL directly. It is not an IP library The term IP (Intellectual Property) is used in the context of hardware design\nto refer to hardware blocks that are designed to be easily reusable in other\ndesigns. MyHDL does not contain IP blocks. What it provides is the raw material to\ndesign them. Actually, MyHDL is the ideal platform for IP block development,\nbecause of its powerful Python foundation, and because it provides a path into\nboth Verilog and VHDL design flows with a single development effort. Not just for implementation MyHDL is very effective to describe a hardware implementation. The\ncorresponding abstraction level is called RTL (Register Transfer Level).\nTypically, RTL code is converted into hardware implementation by a synthesis tool. Another name for RTL is therefore synthesizable code. However, MyHDL is not an RTL-only language. This point is frequently\nmisunderstood, even though it is also valid for mainstream HDLs such as Verilog\nand VHDL. MyHDL is a library for general event-driven modeling and simulation of hardware\nsystems. There are many reasons why it can be useful to model at a higher level\nof abstraction than RTL. For example, you can use MyHDL to verify architectural\nfeatures, such as system throughput, latency and buffer sizes. You can also\nwrite high level models for specialized technology-dependent cores that are not\ngoing through synthesis. Last but not least, you can use MyHDL to write test\nbenches that verify a system model or a synthesizable description. RTL is just a specific and restrictive way to use MyHDL's modeling capabilities\nwith the goal to create synthesizable code. Not well suited for timing simulation MyHDL's delay model is simple, which is fine for RTL and higher levels of\nabstraction. These are the levels where MyHDL is strong. However, MyHDL's timing model is not suited for accurate timing simulations,\nwhich are typically useful at the gate level. For such simulations, it is\nadvisable to use industry standard Verilog or VHDL simulators, which are\noptimized for the task. Moreover, gate level simulation libraries are typically\navailable in those formats from silicon vendors. In a MyHDL-based design flow,\nthis methodology is logical, because all tasks below RTL are part of the\n\"back-end\". The synthesis tool will create a gate level net list in Verilog or\nVHDL format. MyHDL can still play a significant role in gate-level simulations, thanks to\nits co-simulation capabilities. This means that you can reuse all MyHDL test\nbenches that were developed for RTL verification to control gate level\nsimulations.", 
            "title": "What MyHDL is not", 
            "url": "/start/whatitisnot.html"
        }, 
        {
            "tags": "", 
            "text": "Installation using pip You can install MyHDL using pip: pip install myhdl To upgrade an existing installation to the\nlatest version, use: pip install --upgrade myhdl If pip is not yet available on your system, follow the pip installation\ninstructions . You may want to install MyHDL in an isolated environment using virtualenv . Installation using distutils MyHDL uses the standard Python distutils package for distribution and\ninstallation. This page contains detailed instructions for installing MyHDL on\na typical Linux or Unix system. For other platforms, you have to follow an\nequivalent procedure. Remember that MyHDL can be installed on any platform that\nsupports Python. For more information about installing on non-Linux platforms\nsuch as Windows, read about Installing Python\nModules . To install MyHDL on your system, download the\nlatest release. Untar and unzip the downloaded file: > tar xvf myhdl-0.9.0.tar.gz\n> gunzip myhdl-0.9.0.tar Go into the release directory: > cd myhdl-0.9.0 If you have superuser power, you can install MyHDL as follows: > python setup.py install This will install the package in the appropriate site-wide Python\npackage location. Otherwise, you can install it in a personal directory, e.g. as\nfollows: > python setup.py install --home=$HOME In this case, be sure to add the appropriate install dir to the $PYTHONPATH . If necessary, consult the distutils documentation in the standard\nPython library for more details. You can test the proper installation as follows: > cd myhdl/test/core\n> py.test Co-simulation Co-simulation requires an additional installation step. To install co-simulation support: Go to the directory co-simulation/<platform> for your target platform\nand following the instructions in the README.txt file.", 
            "title": "Installation", 
            "url": "/start/installation.html"
        }, 
        {
            "tags": "", 
            "text": "Introduction Why MyHDL? Here is a good reason: MyHDL is open-source software that you can\nuse for free.  However, there are many other good reasons why MyHDL is worth\nconsidering.  This page describes a number of common situations and opinions,\nand how MyHDL addresses them. If you recognize them, MyHDL may be a good\nsolution for you. New to digital hardware design Let's be honest about it: there's a lot to learn and it will be hard work.\nHowever, choosing the right development language can make the task\nsignificantly easier. Python is one of the easiest programming languages to\nlearn, and MyHDL aims to achieve the same for hardware design. Moreover, with MyHDL you can convert your designs automatically to both Verilog\nand VHDL. So you keep all your options open. Dynamic language power If you're a practicing hardware designer, you're probably using dynamic\nlanguages (sometimes called \"scripting\" languages) in your workflow already.\nFor example, tcl is popular for tool control.  Also, many designers use perl to\nglue things together. Others use ruby or Python for that purpose. It is clear that these high-level dynamic languages play an essential role in\nmodern digital design. Verilog or VHDL alone is not enough. Many designers even\nprefer those languages over their HDL, because they can get things done quickly\nwith them. Wouldn't it be great if one could use such a language directly to design\nhardware?  That's exactly what MyHDL offers. Modern software techniques In the software methodology world, a lot of innovation is going on, with\nbuzzwords such as \"agile\", \"rapid application development\", \"scrum\", and\n\"test-driven development\".  This is not just hype. The new ideas and techniques\noffer real improvements to the development processes. Naturally, they are\nemerging in the communities of modern software languages, such as Python. As HDL-based design has many similarities with software development, the new\nideas are potentially quite relevant. Nevertheless, the hardware design world\nseems detached from them. By using MyHDL, the newest software development techniques are readily\navailable to the hardware designer, thanks to its Python foundation.  For\nexample, you can use a Python unit test framework to do test-driven development\nfor hardware design. Algorithm and implementation unified Python is an ideal language for algorithm development and many engineers use it\nfor this purpose.  Commonly this work and a subsequent HDL implementation are\ndone by different engineers.  They use a different set of tools that require a\nspecialized level of knowledge. MyHDL is a big step towards the unification of the two domains.  With\nPython/MyHDL an algorithm or model designer can explore HDL implementation and\nan HDL designer can explore algorithm and model design, all within the same\nenvironment.  Of course, the conversion from algorithm to an HDL implementation\nstill requires knowledge of HDL-based design. But being able to do this while\nstaying in the powerful Python environment can be a significant boost to\nquality and productivity.  For example, the verification work can directly be\nreused between both design domains. Target both Verilog and VHDL The usage of Verilog versus VHDL differs significantly between regions and\nsectors.  However, there is every indication that the overall ratio is about\nfifty-fifty, and will remain so in the forseeable future. Consequently, it is\noften desirable that a design be available in the \"other\" language also. For IP\ndevelopers, this may even be an explicit design goal. Using MyHDL is a solution. A MyHDL design can be automatically converted to\nequivalent code in both Verilog and VHDL.  Actually, using MyHDL and conversion\nis probably the best solution available for language-neutral design. It is\nobviously superior to manual conversion. Moreover, direct convertors between\nVerilog and VHDL don't work very well. Using a syntactically simple language\nlike Python as the starting point is an easier way to a create a high-quality\nconversion tool. Explicit, but not verbose VHDL has many virtues, but conciseness is not one of them. Many feel that the\nsyntax is verbose and even redundant, and even experts need a manual nearby to\nget the syntax right. Python is different. It is concise. One reason is that it is a dynamic language\nwithout declarations. But the major reason is its well thought out design.\nMoreover, it achieves this without resorting to \"magic\".  The code remains\nexplicit, but the syntax has been reduced to the essence. Python has been\ncalled executable pseudocode, and that's actually a quite accurate description. Power, not complexity SystemVerilog has been called a \"dumping ground\" for any feature ever dreamed\nup by an EDA company. Through the process of \"donations\", the language contains\nan ever increasing pile of builtin constructs and features. Of course, not all\nof them can be equally important or well designed. The experience can be\noverwhelming. One might think that language complexity is a necessary consequence of feature\ncomplexity. However, a language like Python shows that this is not true.  The\ncore Python language is actually very small. However, it is designed for\nextensibility and modularity. Most of the action happens in libraries, with the\ncore language serving as a common ground. There is an extensive standard\nlibrary that comes with the distribution. In addition, there is a vast amount\nof third-party libraries available for all kinds of functionality. MyHDL is an\nexample. Python's modular structure explicitly separates the essential from the\nsecondary.  After learning the small core language, you only need to study and\nimport those libraries that contain the functionality that you need.  This is a\nsuperior and scalable way of dealing with complexity. Signals and variables, like VHDL One of the most confusing aspects of Verilog is about the difference between\nblocking and non-blocking assignments.  Actually, if you are not confused\nabout this, you probably don't have enough experience :-). Here is the problem. The semantics of blocking ( = ) versus non-blocking ( <=) assignments are radically different. So different in fact that a language like\nVHDL (and MyHDL) uses dedicated objects called signals to implement\nnon-blocking semantics. However, in Verilog, you can use and mix the two types\nof assignments on any object. In many cases, Verilog's permissiveness on this matter is senseless and\nconfusing.  Consequently, most designers follow guidelines on acceptable use\npatterns. Unfortunately, as a testimony to the initial confusion, such\nguidelines can be overly restrictive.  For example, a commonly used guideline\nbasically forbids variable semantics in clocked synthesizable processes\ncompletely! MyHDL follows the sensible example of VHDL. It has dedicated signal objects and\nsignal assignments that correspond to the semantics of Verilog non-blocking\nassignments. The clear separation between signals and variables avoids the\nconfusion about the two types of assignment. Signal assignments done right Hardware Description Languages need a way to describe racefree communication\nbetween parallel hardware blocks. This is the purpose of VHDL signal\nassignments and Verilog non-blocking assignments. In both languages, these\nassignments are implemented using a special assignment symbol, which happens to\nbe identical: <= .  We will refer to \"signal assignments\" in the following\ndiscussion. As signal assignments are not natively present in software languages, HDL\nnewcomers often have problems with them. While this is a normal part of the\nlearning process, the VHDL and Verilog approach doesn't help.  Consider the\nfollowing pseudocode snippet of signals assignments: a <= b\nb <= a Even when this code is inside procedural code, the semantics are concurrent. In\nparticular, the value of a used on the second line is not the one assigned\nto a on the first. The value used is the current value, while the value\nassigned is the future value of a . MyHDL uses a different approach. Instead of a special assignment symbol for\nsignals, it uses attribute assignment to the special attribute next .\nAttribute assignment is common in object-oriented languages.  Our example\nbecomes: a.next = b\nb.next = a In this way, it is explicitly clear that the assigment on the first line isn't\nmodifying the current value, but the next value of the signal. A MyHDL designer merely has to learn that a signal's future value should be\nmodified by assigning to its next attribute. From there on, the semantics are\nclear from the code. Straighforward integer arithmetic When writing synthesizable VHDL code, you typically use the signed and unsigned\ntypes for arithmetic operations. These are \"representational\" types that focus\non bit representation and bit width. The operators defined for such types have\nstringent requirements on the types and bit widths of operands and results.  As\na result, you typically need a lot of conversion functions and resizings.  Many\ndesigners take this for granted and view it as a result of VHDL's strong\ntyping. In reality, it is a consequence of using low-level types. MyHDL follows a different path, but one that has actually been shown by VHDL in\nthe first place. It has the intbv type, which is an integer-like type whose\nvalues can be constrained like in VHDL. However, unlike VHDL, there are no\nartificial limits on the minimum and maximum values it can take.  Moreover, and\nagain unlike VHDL, the type has an indexing and slicing interface to access the\nrepresentation if required. The result is that in synthesizable MyHDL, you can basically do arithmetic\nusing integers. Therefore, all issues with signed/unsigned representations\nsimply disappear.  The convertor to VHDL infers the required conversions and\nresizings automatically, thereby automating a cumbersome task. Signed arithmetic that works Signed arithmetic in Verilog can be quite confusing. The reason is that when\nyou mix signed and unsigned operands, the operation is done in unsigned mode.\nThis is the opposite of what should be done to get the normally expected\nresults. To avoid this, operands should be explicitly cast to signed. In MyHDL, these issues do not exist, because you can basically use integers for\narithmetic, using the intbv type presented in the previous section.  The\nconvertor to Verilog infers the required casts and bit extensions\nautomatically.", 
            "title": "Why MyHDL?", 
            "url": "/start/why.html"
        }, 
        {
            "tags": "", 
            "text": "Overview Installation Why MyHDL? What MyHDL is not", 
            "title": "Start", 
            "url": "/start/index.html"
        }, 
        {
            "tags": "", 
            "text": "Short description MyHDL is a free, open-source package for using Python as a hardware description\nand verification language. Python is a very high level language, and hardware\ndesigners can use its full power to model and simulate their designs.\nMoreover, MyHDL can convert a design to Verilog or VHDL. This provides a path\ninto a traditional design flow. Modeling Python's power and clarity make MyHDL an ideal solution for high level\nmodeling.  Python is famous for enabling elegant solutions to complex modeling\nproblems.  Moreover, Python is outstanding for rapid application development\nand experimentation. The key idea behind MyHDL modeling is the use of Python generators to model\nhardware concurrency. Generators are best described as resumable functions.\nMyHDL generators are similar to always blocks in Verilog and processes in VHDL. A hardware module is modeled as a function that returns generators. This\napproach makes it straightforward to support features such as arbitrary\nhierarchy, named port association, arrays of instances, and conditional\ninstantiation.  Furthermore, MyHDL provides classes that implement traditional\nhardware description concepts. It provides a signal class to support\ncommunication between generators, a class to support bit oriented operations,\nand a class for enumeration types. Simulation and Verification The built-in simulator runs on top of the Python interpreter. It supports\nwaveform viewing by tracing signal changes in a VCD file. With MyHDL, the Python unit test framework can be used on hardware designs.\nAlthough unit testing is a popular modern software verification technique, it\nis still uncommon in the hardware design world. MyHDL can also be used as hardware verification language for Verilog designs,\nby co-simulation with traditional HDL simulators. Conversion to Verilog and VHDL Subject to some limitations, MyHDL designs can be converted to Verilog or VHDL.\nThis provides a path into a traditional design flow, including synthesis and\nimplementation.  However, the convertible subset is much wider than the\nstandard synthesis subset, and includes features that can be used for high\nlevel modeling and test benches. The converter works on an instantiated design that has been fully elaborated.\nConsequently, the original design structure can be arbitrarily complex.\nMoreover, the conversion limitations apply only to code inside generators.\nOutside generators, Python's full power can be used without compromising\nconvertibility. Finally, the converter automates a number of tasks that are hard in Verilog or\nVHDL directly. A notable feature is the automated handling of signed arithmetic\nissues.", 
            "title": "Overview", 
            "url": "/start/overview.html"
        }, 
        {
            "tags": "", 
            "text": "MyHDL's page of Benoît Allard PureDarwin is a pure hardware implementation of CoreWare : https://bitbucket.org/benallard/puredarwin At the moment, it is not convertible, as lots of tests, as well as some tracebenchs in order to simulate it and observe the output in a vcd file (gtkwave). It is considered as being simulation capable. Documentation is available on readthedocs: http://puredarwin.readthedocs.org/ Status of the project is documented, the ToDo is a good place to start also.", 
            "title": "Benoît Allard", 
            "url": "/users/benallard.html"
        }, 
        {
            "tags": "", 
            "text": "MyHDL's creator and BDFL All info can be found on my website http://www.jandecaluwe.com .", 
            "title": "Jan Decaluwe", 
            "url": "/users/jandecaluwe.html"
        }, 
        {
            "tags": "", 
            "text": "", 
            "title": "Users", 
            "url": "/users/index.html"
        }, 
        {
            "tags": "", 
            "text": "cfelton's contributions MEPs The following are MyHDL enhancement proposals I have contributed (the implementations not always completed by me): Interfaces , object attribute \n     conversion (implemented by @jck ). Top-level method conversion . fixed-point object: fixbv", 
            "title": "Contributions", 
            "url": "/users/cfelton/contrib.html"
        }, 
        {
            "tags": "", 
            "text": "cfelton's projects Projects The following are the list of MyHDL projects and examples\nI have created and shared. MyHDL Projects rhea : A collection\n     of cores writen in MyHDL and an FPGA build framework. MyHDL Shared Code examples alt.hdl test_jpeg gist Projects Contributing MyHDL (obviously) pyFDA", 
            "title": "Projects", 
            "url": "/users/cfelton/projects.html"
        }, 
        {
            "tags": "", 
            "text": "user and developer I have been using MyHDL and contributing to the project for\nmany years now.  I have successfully used MyHDL in the creation\nof multiple mixed-signal ASICs and used it for numerous FPGA \nprojects.  See the following pages for more information on some \nof my projects and writings: Projects Writings Contributions", 
            "title": "Christopher L. Felton", 
            "url": "/users/cfelton/index.html"
        }, 
        {
            "tags": "", 
            "text": "cfelton's writings Blog Posts MyHDL Resources Introduction to fixed-point by example The wheels go round and round : \n     two's compliment number representation and some fixed-point comments. MyHDL FPGA Tutorial I (LED strobe) MyHDL FPGA Tutorial II (audio echo) MyHDL FPGA Tutorial II continued MyHDL interface example Little to no benefit from C based HLS Industry is ready for HLS Python scipy.signal IIR filter design Python scipy.signal IIR filter design cont. Python scipy.signal IIR filter: an example Python number crunching faster Impulse response approximation Conference Papers, Presentations, and Posters 2014 Embedded Systems Conference: presentation and examples 2013 Embedded Systems Conference: paper and presentation 2013 PyOhio Conference Presentation: presentation video 2011 FPGA Camp: poster 2010 Signal Processing with FPGAs: presentation", 
            "title": "Writings", 
            "url": "/users/cfelton/writings.html"
        }, 
        {
            "tags": "", 
            "text": "cfelton's examples", 
            "title": "Examples", 
            "url": "/users/cfelton/examples.html"
        }, 
        {
            "tags": "", 
            "text": "", 
            "title": "User H", 
            "url": "/users/user-h/index.html"
        }, 
        {
            "tags": "", 
            "text": "Tutorials FPGA Tutorial I FPGA Tutorial II", 
            "title": "Resources", 
            "url": "/support/resources.html"
        }, 
        {
            "tags": "", 
            "text": "Modeling What is the default width of an intbv ? By default, an intbv object has an \"indefinite\" bit width. Although this is a novel concept compared to traditional HDL modeling, it corresponds to the natural way to think about integers and their 2's complement representation. Consider: >>> from myhdl import intbv >>> a = intbv ( 5 ) >>> a [ 75 ] = 1 >>> a intbv ( 37778931862957161709573 L ) >>> a [ 77 : 74 ] intbv ( 2 L ) This illustrates that you can index and slice an intbv object with arbitrary indices, without having to declare a bit width at object construction time. The default is fine for modeling at a very high level. Other applications require a defined bit width, and this is supported by the intbv class also. How do I define the width of an intbv ? To define the bit width of an intbv object, you have two options. The first method is an indirect one that specifies the acceptable value range using the min and max parameters. For example: a = intbv ( 0 , min =- 24 , max = 75 ) As always in Python, the minimum value is inclusive, but the maximum value is exclusive. Note how this method stresses the \"integer\" nature of an intbv . The second method defines the bit width directly, as follows: a = intbv ( 0 )[ 8 :] This works because when you take a slice from an intbv, the returned object is a new intbv with a bit width w corresponding to the slicing range. The min and max value are set to 0 and 2**w respectively. Note that the object returned by a slice is always positive, as in Verilog. The range of acceptable values of an intbv object is checked at simulation runtime. This is an interesting application of defining a bit width. Another application is implementation-oriented modeling, such as code that needs to be converted automatically to synthesizable Verilog. How can I model wrap-around behaviour? In HDLs such as Verilog and VHDL, the bit vectors have wrap-around behaviour. This means that when the result of a numeric operation would exceed the bit width, the higher order bits are dropped automatically. In effect, the operations are done modulo the power of 2 of the bit width. MyHDL's intbv object is much like an integer. Therefore, it doesn't have this wrap-around behavior. If needed, it has to be described explicitly. The most straightforward way to describe wrap-around behavior is with an if-then-else. For example: if count < N : count . next = count + 1 else : count . next = 0 This may seem a little verbose compared to automatic wrap-around, but in many cases there is no overhead. Often, something else will have to be done depending on the condition (such as setting a control signal) so you can directly add that in the code. Moreover, the wrap-around condition is not limited to powers of 2. To describe wrap-around behaviour with a one-liner, you can use the modulo operation: count . next = ( count + 1 ) % N Conversion to Verilog and VHDL How can I use third-party modules? You can use user-defined code to replace a MyHDL module by a corresponding instantiation. Why is the conversion output non-hierarchical? The conversion output is non-hierarchical because conversion works\non a design instance elaborated by the Python interpreter. This\nprocess flattens out all hierarchy. You can generate hierarchical designs by some additional work,\nin particular by converting lower level modules and using\nuser-defined instantiation code at a higher level. This\ntechnique is explained here . Co-simulation How can I run co-simulation on Windows? The implementation of co-simulation in MyHDL relies on unix-style interprocess communication. Therefore, unlike the rest of MyHDL, you cannot use co-simulation on Windows natively. To run co-simulation on Windows, use a unix-like environment for Windows, such as cygwin. You will have to compile all co-simulation tools in that environment. This includes Python itself, the HDL simulator, and the PLI module. Users have reported co-simulation success on Windows using cygwin and the Verilog simulators Icarus and Cver.", 
            "title": "FAQ", 
            "url": "/support/faq.html"
        }, 
        {
            "tags": "", 
            "text": "Jan Decaluwe Jan Decaluwe, MyHDL's creator and maintainer, is available for commercial MyHDL\nsupport, consulting and contract work on MyHDL-based design projects. For more information, check out his website . To discuss commercial projects, send an email to Jan Decaluwe .", 
            "title": "Commercial support", 
            "url": "/support/commercial.html"
        }, 
        {
            "tags": "", 
            "text": "The MyHDL discourse forum is used to\nexchange information about MyHDL.  Beginner and advanced discussions\nare welcomed on the forum.  The forum, for all\npractical purposes, has replaced the mailing-list.  For more iformation\non the mailing-list see below. In addition to the forum there is an active gitter channel and a #myhdl IRC channel\non freenode The MyHDL Mailing List was\nused heavily in the past but has been primarily replaced by the discourse forum and gitter channel . The mailing list is archived on http://gmane.org , which\nprovides a bidirectional gateway to the mailing list. Gmane\nlets you choose among a variety of interfaces to\naccess and search the mailing list information. Moreover,\nthere is no need to subscribe. All interface options are described here: http://dir.gmane.org/gmane.comp.python.myhdl . In particular, to access the list as a usenet newsgroup, you\ncan use this link: The MyHDL Newsgroup", 
            "title": "Community", 
            "url": "/support/community.html"
        }, 
        {
            "tags": "", 
            "text": "FAQ Community Issue Tracker Resources Development documentation Commercial support", 
            "title": "Support", 
            "url": "/support/index.html"
        }, 
        {
            "tags": "", 
            "text": "Release news General news", 
            "title": "News", 
            "url": "/news/index.html"
        }, 
        {
            "tags": "", 
            "text": "MyHDL is now on twitter: follow @MyHDL .", 
            "title": "Follow MyHDL on twitter!", 
            "url": "/news/general/2013-04-24.html"
        }, 
        {
            "tags": "", 
            "text": "Today, myhdl.org got a complete makeover.\nRead about the rationale and the new system .", 
            "title": "A makeover for myhdl.org", 
            "url": "/news/general/2014-03-18.html"
        }, 
        {
            "tags": "", 
            "text": "Today, MyHDL merged complete Python3 support in the development master branch on github .", 
            "title": "Python3 Support", 
            "url": "/news/general/2015-03-18.html"
        }, 
        {
            "tags": "", 
            "text": "18-Mar-2015 Python3 Support Today, MyHDL merged complete Python3 support in the development master branch on github . 18-Mar-2014 A makeover for myhdl.org Today, myhdl.org got a complete makeover.\nRead about the rationale and the new system . 24-Apr-2013 Follow MyHDL on twitter! MyHDL is now on twitter: follow @MyHDL .", 
            "title": "General news", 
            "url": "/news/general/index.html"
        }, 
        {
            "tags": "", 
            "text": "Check out what's new .", 
            "title": "MyHDL 0.11.0 released", 
            "url": "/news/releases/2019-05-31.html"
        }, 
        {
            "tags": "", 
            "text": "A maintenance release for 0.8.", 
            "title": "MyHDL 0.8.1 released", 
            "url": "/news/releases/2014-08-26.html"
        }, 
        {
            "tags": "", 
            "text": "Check out what's new .", 
            "title": "MyHDL 0.7 released", 
            "url": "/news/releases/2010-12-24.html"
        }, 
        {
            "tags": "", 
            "text": "Check out what's new .", 
            "title": "MyHDL 0.9.0 released", 
            "url": "/news/releases/2015-07-13.html"
        }, 
        {
            "tags": "", 
            "text": "Check out what's new .", 
            "title": "MyHDL 0.10.0 released", 
            "url": "/news/releases/2018-05-09.html"
        }, 
        {
            "tags": "", 
            "text": "31-May-2019 MyHDL 0.11.0 released Check out what's new . 09-May-2018 MyHDL 0.10.0 released Check out what's new . 13-Jul-2015 MyHDL 0.9.0 released Check out what's new . 26-Aug-2014 MyHDL 0.8.1 released A maintenance release for 0.8. 20-May-2013 MyHDL 0.8 released Check out what's new . 24-Dec-2010 MyHDL 0.7 released Check out what's new . 09-Jan-2009 MyHDL 0.6 released Check out what's new .", 
            "title": "Release news", 
            "url": "/news/releases/index.html"
        }, 
        {
            "tags": "", 
            "text": "Check out what's new .", 
            "title": "MyHDL 0.6 released", 
            "url": "/news/releases/2009-01-09.html"
        }, 
        {
            "tags": "", 
            "text": "Check out what's new .", 
            "title": "MyHDL 0.8 released", 
            "url": "/news/releases/2013-05-20.html"
        }, 
        {
            "tags": "", 
            "text": "MyHDL is fast! The message from this page is loud and clear: MyHDL is fast! MyHDL is implemented as a pure Python application. Python is a very\nhigh-level, dynamically typed language. Traditionally, such languages have\na much worse performance than statically typed languages. Moreover, it is\nusually taken for granted that there is a trade-off between expressive\npower and performance. However, thanks to technological advances it is time to challenge the\nconventional wisdom, for Python and for MyHDL in particular. In contrast to\nwhat you might expect, using MyHDL does not necessarily imply a\nsimulation performance penalty when compared to statically typed HDLs like\nVerilog or VHDL. If you think this is impossible, read on. To make MyHDL simulations fast, all you have to do is to use the right\nPython interpreter, which may be different than the one you are using\ntoday. The interpreter of choice is developed by the the PyPy\nproject and comes with a Just-In-Time (JIT) compiler. The\nJIT compiler does the trick: it can aggressively optimize those parts of\nthe code that matter, by inspecting the characteristics of the running\nprogram. If the prospect of using a different, unfamiliar interpreter sounds scary,\ndon't worry. Compatiblity with Python is a major goal of the PyPy project.\nPyPy is highly compliant with Python 2.7 and can basically be used as a\ndrop-in replacement. The process is similar to upgrading to a new version\nof Python. However, it is an upgrade with spectacular consequences. Using PyPy to speed up MyHDL simulations To demonstrate what PyPy can do for MyHDL simulations, I have compiled a\nnumber of representative hardware design benchmarks. I run them both with\nthe reference Python interpreter ( cPython ) and with the JIT-enabled PyPy\ninterpreter ( pypy ) and time them. The results are as follows (times in\nseconds): Benchmark MyHDL@cPython MyHDL@pypy Speedup factor timer 902 61 14.8 lfsr2 1,307 67 19.5 randgen 763 62 12.3 longdiv 752 69 10.9 findmax 670 86 7.8 As you can see, the results are spectacular. By simply using a different\ninterpreter, our simulations run 8 to 20 times faster. When it comes to\ninstant improvements without compromises, it doesn't get better than this! I have initially engineered the benchmarks so that they run for about 100s\nfor PyPy 1.5. This leaves some margin to easily compare them in the future\nwith runs on better machines and with future PyPy versions. Also, to get a\nrealistic idea of the speedup factor, the simulations should run long\nenough. More details can be found here . Perhaps we should temper our initial enthusiasm a little. After all, we are\nstill comparing MyHDL to MyHDL. Perhaps we have merely gone from extremely\nbad to very bad. To get more insight in were we are, we should compare with\nequivalent benchmarks in Verilog and VHDL. Comparison to VHDL and Verilog The benchmarks are implemented as self-contained test benches that can be\nconverted automatically to Verilog and VHDL (by MyHDL). I have run them on\ntwo Verilog simulators and two VHDL simulators. All simulators are\navailable at no cost, but two of them have to be kept anonymous. I have\ncalled those simulators and . The other ones are the open\nsource simulators Icarus (Verilog) and GHDL (VHDL). Here are the results\n(times in seconds): Benchmark MyHDL@pypy Icarus GHDL timer 61 106 146 260 219 lfsr24 67 79 71 266 240 randgen 62 197 34 76 67 longdiv 69 43 224 96 98 findmax 86 56 2256 21 37 A first thing to note is that the results go in all directions, sometimes\nin an astonishing way. There is no clear \"winner\". Some simulators perform\nbad in some benchmarks, and good in others. Therefore, the data suggests\nthat the benchmarks form a good set that covers various aspects of hardware\nsimulation. Moreover, there seems no correlation between the VHDL simulators, nor\nbetween the Verilog simulators. This indicates that there is nothing wrong\nwith the quality of the Verilog and VHDL code generated by MyHDL. The most important conclusion: MyHDL is doing just fine. In two benchmarks, it is actually the fastest simulator, and it is never the slowest one. The comparatively weakest performance is in the findmax benchmark, which is also the benchmark with the smallest speedup factor from using PyPy. The results for other simulators are remarkable also. For example, GHDL\nshows a very good performance in the randgen benchmark, but a very bad\none for the findmax benchmark. In the latter case it is 100 times slower\nthan the fastest simulator. Clearly, it should be interesting for other\ndevelopers to look into the details of the benchmarks. More info on the benchmarks can be found here . A note on paid-license commercial simulators The benchmark data are all from zero cost HDL simulators. I think that is\nfair and the reasons are understandable. Note that even if I would have the\nnumbers for paid-license commercial simulators, I would typically not be\nlegally allowed to publish them. As performance is such an important competitive driver, you can reasonably\nexpect significantly better performance from paid-license Verilog and VHDL\nsimulators. One simulation vendor has granted permission to publish\nnumbers: Tachyon with their cvc Verilog\nsimulator. Performance is the name of the game for cvc, and it really is\nblazingly fast: in compiled mode, all benchmarks but one run in times\nbetween 2.2s and 2.5s. ( longdiv takes just 1s.) If you need\nhigh-performance Verilog simulation, cvc is definitely worth a look. Tachyon convincingly claims that it outperforms any other commercial\nsimulator with a factor 2-20. This would mean that the benchmarks would run\nin times between 4.4s and 50s for other paid-license simulators. (2s-20s\nfor longdiv ). Analysis By simply changing the Python interpreter, MyHDL is playing in the same\nleague as Verilog and VHDL simulators. This is a remarkable achievement,\ngiven that Python's power stays completely available. There is no reason\nanymore to avoid MyHDL because of performance concerns. The results are a great validation the concept behind MyHDL. MyHDL is based\non the idea that digital hardware design is not special enough to warrant\nthe design of a dedicated hardware description language, at least not at\nthe RTL level and higher. Instead, everything needed can be done with a\ndedicated library and dedicated usage of a general purpose language. The\nimplication is that one benefits from all advances in the underlying\nlanguage, even if they seem unrelated to the specific purpose. For example,\nthe PyPy team is not trying to make hardware simulation fast. What they do\nis making Python fast in general. The numbers are much better than the average speedup of the standard PyPy\nbenchmark set, which stands at 4.1 for PyPy 1.6. This suggests that\nMyHDL simulation is well suited for JIT optimization. I believe this can be\nexplained by considering the characteristics of a typical MyHDL simulation\nrun. It consists of two phases: first an elaboration phase that creates a\nsimulatable data structure, followed by the actual simulation phase. The\nelaboration phase is typically very fast and may use a lot of Python's\ndynamic features. The simulation phase can run for a long time. However,\nthe simulatable data structure is typically rather \"static\" and probably a\ngood target for the JIT compiler. It consists of generators, connected by\nsignals and controlled by a simulation engine. The code within the\ngenerators is typically a loop containing integer arithmetic and bit\noperations. A personal note --- Jan Decaluwe 2011/06/06 04:57 Occasionally, I make bold predictions. In many cases they just stay wishful\nthinking. This is one of the rare cases when they turn out to be right.\nTherefore, please allow me a brief moment of glory. Here is a quote from a\npost in 2006: > From: Jan Decaluwe jan@jandecaluwe.com\n> Subject: Re: MyHDL performance\n> Newsgroups: gmane.comp.python.myhdl\n> Date: 2006-11-30 10:19:47 GMT \n> \n> ...\n> Finally, there is PyPy. I once saw a demo by\n> Armin Rigo showing a massive speedup by using\n> psyco. Unfortunately, psyco cannot handle \n> generators. Instead, Armin and others started\n> the PyPy project that at one time may bring\n> psyco-like advantages to general Python code.\n> It would seem to me that MyHDL is a good\n> candidate, because a lot of code is run over\n> and over again during simulation.\n\n> So perhaps one day I'll be able to report a \n> massive speedup  without having to do anything\n> myself :-) That will be the day!\n> ... The day when I can report a massive speedup has arrived now. As it turns\nout, the results for MyHDL are indeed particularly good. And it really was\nArmin Rigo and his fellow PyPy team members who have pulled it off. I would like to express my respect and gratitude to the PyPy team and their\nachievements. They have a great vision, as well as the technical excellence\nand perseverance to make it happen. When I briefly described JIT optimization earlier, I tried to make it sound\nintuitive and easy. Intuitive it may be, but easy certainly not. There have\nbeen several attempts to speed up Python in the past, including one\nsponsored by Google (Unladen Swallow.) So far, the PyPy project is the\nfirst and only one that can truly be called a great success. Interestingly, the PyPy team did not really write a JIT compiler for\nPython. I guess that would have been too easy :-). Instead they wrote a JIT\ncompiler generator , that can generate a JIT enabled interpreter for any\nlanguage written in a Python subset called RPython (for \"Restricted\nPython\"). In other words, the goodies they provide are not restricted to\nthe Python world. I see glimpses of greatness in the PyPy project, and I believe we are going\nto hear a lot more about them in the future. Technical details Benchmark details All benchmarks are implemented as self-contained test benches. The design\nunder test in each test bench is a synthesizable RTL description of a\ntypical hardware module. The test benches are self-checking using assert\nstatements, except randgen which creates an output file. They have been\nwritten in MyHDL in such a way that they can be converted automatically to\nVerilog and VHDL. The functionality corresponding to the design under test in the benchmarks\nis the following: timer A circuit that continuously emits a pulse after a fixed number of\nclock cycles. Implemented using an incrementer. lfsr24 A classical bit-serial linear feedback shift register, based on\na polynomial of length 24. randgen A pseudo-random generator in hardware with a 32-bit output\nword. Implemented by putting a loop around an lfsr of length 64. longdiv A long division algorithm. Implemented as an FSM that\ncalculates one bit per clock cycle. findmax A combinatorial network that finds a maximum value out of a set\nof 32 16-bit inputs. The benchmarks are developed in the MyHDL repository. They can be found\nunder myhdl/test/benchmarks . Computing environment I have run all simulations on my laptop with the following characteristics: Processor Intel(R) Core(TM) i3 CPU M 350  @ 2.27GHz Memory 2.4 GiB Operating System Ubuntu 10.04 (lucid) Python 2.6.5 PyPy 1.6.0 MyHDL 0.8-dev Icarus 0.9.4 GHDL 0.29 The JIT warming-up phase A JIT compiler has a slow warm-up phase, during which it examines and\noptimizes the running program. Very fast runs can therefore even be slower\nwith a JIT than without. On the other hand, the longer a program runs, the\nfaster it gets. From what I read, the warm-up phase can take a few seconds\nup to a minute, depending on the size of the program. To get a feeling for\nwhat it may mean for MyHDL, I have run one of the benchmarks ( longdiv )\nseveral times, each time doubling the number of test vectors. The results\nare as follows: log 2 (#vectors) MyHDL@cPython MyHDL@pypy Speedup factor 9 1.7 1.9 0.9 10 3.1 2.2 1.4 11 6.0 2.5 2.4 12 11.9 3.1 3.8 13 23.4 4.2 5.6 14 46.8 6.3 7.4 15 93.9 10.7 8.8 16 186.6 19.1 9.8 17 373.1 35.8 10.4 18 750.7 69.4 10.8 As you can see, the simulation gets up to speed after a few seconds. To get\nthe initial offset out of the speedup factor, it has to run long enough.\nFor this reason, I have engineered the benchmarks so that the PyPy version\nruns for around 100s. Installation, hints, and known issues To get started with PyPy, you may want to install it alongside your current\nPython interpreter. This is fairly easy to do by following these installation instructions .  In\nthis way you can have a pypy interpreter next to your python interpreter and switch between them as needed. If you use a test framework like py.test you can select the desired\ninterpreter by using the command python -m py.test or pypy -m py.test . Historical data The PyPy project is under intensive development. New revisions can result\nin significant improvements, but this depends heavily on the application. Between pypy-1.6 and pypy-1.9, the results for the MyHDL benchmarks have\nstagnated or become slightly worse. The following table keeps track\nof the historical benchmark data. Benchmark pypy-1.5 pypy-1.6 pypy-1.7 pypy-1.8 pypy-1.9 timer 85 61 60 62 65 lfsr24 104 67 82 78 75 randgen 91 62 56 62 63 longdiv 87 69 81 71 70 findmax 112 86 89 98 98 The benchmark data has not yet been updated for the latest pypy versions.  At\nthe time this update, pypy is at version number 2.2.", 
            "title": "Performance", 
            "url": "/docs/performance.html"
        }, 
        {
            "tags": "", 
            "text": "Manual Examples Performance", 
            "title": "Docs", 
            "url": "/docs/index.html"
        }, 
        {
            "tags": "", 
            "text": "Introduction On this page we will present the design of a reversable 4 bit Johnson counter.\nA Johnson counter has a special structure that permits glitch-free decoding. This example is originally from the Xilinx ISE design environment. If you wish,\nyou can download the free version of the Xilinx\nISE to review the original design and use it as a reference. Specification A Johnson counter basically consists of a circular shift register with an invertor in the loop. The specification of the counter operation is as follows: The counter is triggered on the rising edge of the clock (clk). \nA low pulse on the goLeft input will cause the counter to start \nshifting left from its current state. A low pulse on the goRight\ninput will cause the counter to start shifting right from its \ncurrent state. A low pulse on the stop input will cause the \ncounter to hold its current state until goLeft or goRight is pulsed.\nAfter power-up, the counter is stopped with all outputs low (LEDs lit). MyHDL code The MyHDL code for this design looks as follows. from myhdl import * ACTIVE = 0 DirType = enum ( 'RIGHT' , 'LEFT' ) @block def jc2 ( goLeft , goRight , stop , clk , q ): \"\"\" A bi-directional 4-bit Johnson counter with stop control. I/O pins: -------- clk      : input free-running slow clock goLeft   : input signal to shift left (active-low switch) goRight    : input signal to shift right (active-low switch) stop     : input signal to stop counting (active-low switch) q        : 4-bit counter output (active-low LEDs; q[0] is right-most) \"\"\" dir = Signal ( DirType . LEFT ) run = Signal ( False ) @always ( clk . posedge ) def logic (): # direction if goRight == ACTIVE : dir . next = DirType . RIGHT run . next = True elif goLeft == ACTIVE : dir . next = DirType . LEFT run . next = True # stop if stop == ACTIVE : run . next = False # counter action if run : if dir == DirType . LEFT : q . next [ 4 : 1 ] = q [ 3 :] q . next [ 0 ] = not q [ 3 ] else : q . next [ 3 :] = q [ 4 : 1 ] q . next [ 3 ] = not q [ 0 ] return logic We use an enumerated type for the direction state dir . We prefer this for\nclarity when the encoding is not specified. Test bench The following is a test bench for a basic verification of the design. from myhdl import * ACTIVE , INACTIVE = bool ( 0 ), bool ( 1 ) from jc2 import jc2 @block def test (): goLeft , goRight , stop , clk = [ Signal ( INACTIVE ) for i in range ( 4 )] q = Signal ( intbv ( 0 )[ 4 :]) @always ( delay ( 10 )) def clkgen (): clk . next = not clk jc2_inst = jc2 ( goLeft , goRight , stop , clk , q ) @instance def stimulus (): for i in range ( 3 ): yield clk . negedge for sig , nrcycles in (( goLeft , 10 ), ( stop , 3 ), ( goRight , 10 )): sig . next = ACTIVE yield clk . negedge sig . next = INACTIVE for i in range ( nrcycles - 1 ): yield clk . negedge raise StopSimulation @instance def monitor (): print ( \"goLeft goRight stop clk q\" ) print ( \"------------------------------\" ) while True : yield clk . negedge yield delay ( 1 ) pStr = str ( ' {:^6} {:^6} {:^5} ' . format ( int ( goLeft ), int ( goRight ), int ( stop ))) yield clk . posedge pStr += \" C \" yield delay ( 1 ) pStr += ' ' + bin ( q , 4 ) print ( pStr ) return clkgen , jc2_inst , stimulus , monitor simInst = test () simInst . config_sim ( trace = True , tracebackup = False ) simInst . run_sim () We use a number of decorated functions to create a clock generator, a stimulus\ngenerator, and a response monitor, together with an instance of the design\nunder test. Such a setup is quite typical. When we simulate this test bench, the output is as follows: goLeft goRight stop clk q\n----------------------------\n  1      1      1    C  0000\n  1      1      1    C  0000\n  0      1      1    C  0000\n  1      1      1    C  0001\n  1      1      1    C  0011\n  1      1      1    C  0111\n  1      1      1    C  1111\n  1      1      1    C  1110\n  1      1      1    C  1100\n  1      1      1    C  1000\n  1      1      1    C  0000\n  1      1      1    C  0001\n  1      1      0    C  0011\n  1      1      1    C  0011\n  1      1      1    C  0011\n  1      0      1    C  0011\n  1      1      1    C  0001\n  1      1      1    C  0000\n  1      1      1    C  1000\n  1      1      1    C  1100\n  1      1      1    C  1110\n  1      1      1    C  1111\n  1      1      1    C  0111\n  1      1      1    C  0011\n  1      1      1    C  0001 You can see the basic operation of the Johnson counter in action. The presented test bench is rather basic. It is fine to get a quick idea about\nthe design behavior, but it is inadequate as a verification tool. First, some\ncorner case are not verified, such as the simultaneous occurence of some of the\ninput signals. Also, it relies on visual inspection which is prone to human\nerror  and not suited for regression testing. A better approach would be to write a self-checking test bench that checks\nJohnson counter properties automatically, plus a number of directed and random\ntests to cover corner cases. In addition, such a test bench should be written\nusing a unit test framework such as Python's unittest package, to facilitate\ntest writing and to make it part of a regression test suite. Consult the MyHDL\nmanual for more info on such techniques. Automatic conversion to Verilog or VHDL A working MyHDL design intended for implementation can be converted to Verilog or VHDL \nautomatically, using the convInst.convert() function. Remember: there is no point in\nconverting when the design doesn't work. The simulation will catch much more\nerrors than the converter. In MyHDL, like in Python, the run-time rules. Conversion to Verilog can be done with code like the following: def convert (): left , right , stop , clk = [ Signal ( INACTIVE ) for i in range ( 4 )] q = Signal ( intbv ( 0 )[ 4 :]) convInst = jc2 ( left , right , stop , clk , q ) convInst . convert ( hdl = 'Verilog' ) convInst . convert ( hdl = 'VHDL' ) convert () As you see, conversion works on an instantiated, elaborated design. The resulting Verilog code is as follows: module jc2 ( goLeft , goRight , stop , clk , q ); // A bi-directional 4-bit Johnson counter with stop control. // // I/O pins: // -------- // clk      : input free-running slow clock // goLeft   : input signal to shift left (active-low switch) // goRight    : input signal to shift right (active-low switch) // stop     : input signal to stop counting (active-low switch) // q        : 4-bit counter output (active-low LEDs; q[0] is right-most) input goLeft ; input goRight ; input stop ; input clk ; output [ 3 : 0 ] q ; reg [ 3 : 0 ] q ; reg [ 0 : 0 ] dir ; reg run ; always @( posedge clk ) begin : JC2_LOGIC if (( goRight == 0 )) begin dir <= 1 'b0 ; run <= 1 'b1 ; end else if (( goLeft == 0 )) begin dir <= 1 'b1 ; run <= 1 'b1 ; end if (( stop == 0 )) begin run <= 1 'b0 ; end if ( run ) begin if (( dir == 1 'b1 )) begin q [ 4 - 1 : 1 ] <= q [ 3 - 1 : 0 ]; q [ 0 ] <= ( ! q [ 3 ]); end else begin q [ 3 - 1 : 0 ] <= q [ 4 - 1 : 1 ]; q [ 3 ] <= ( ! q [ 0 ]); end end end endmodule The tests to the dir variable in the MyHDL code are mapped to a Verilog case statement. This is because the Verilog convertor handles comparisons to\nenumerated type items in a special way. The goal is to describe finite state\nmachines efficiently. For example, it is possible to specify a different\nencoding using the encoding attribute of the enumerated type. The choices are binary (the default), one_hot , and one_cold . Of course, with only 2\nstates like in this case, this functionality is not relevant. But in general,\nit is an additional advantage of the use of enumerated types. Alternative design This is not yet the end of the story. The original design in the Xilinx ISE distribution contains 3 views: Abel,\nVerilog, and VHDL. Interestingly, the Verilog and VHDL views are inconsistent:\nthey have a different behavior. In Verilog terminology, the Verilog view uses\nblocking assignments only, while the VHDL view uses non-blocking (= signal)\nassignments only. The VHDL view seems to be consistent with the Abel view and\nwith the supplied test vectors, so it has been the basis of the design that has\nbeen discussed so far. However, it is interesting to investigate what the\nimplications of the Verilog view would be on the MyHDL code. Actually, the role\nof blocking and non-blocking assignments in Verilog is poorly understood, and I\nbelieve MyHDL can help to clarify the issues. (The reason is that MyHDL, like\nVHDL but unlike Verilog, makes a clear difference between signals and\nvariables). Consider how long it takes before a control input change influences the counter\noutput. In the discussed design, it takes two clock edges: one edge to set the\nstate registers dir and run , and one edge to see the influence of the state\nregisters on the count. You can verify this behavior from the test bench\noutput. (Note that inputs are sampled before the clock edge, and outputs after\nthe clock edge). Now suppose we would prefer to influence the count output after a single clock\nedge. Can this be done? The answer is positive: however, to support that we\nwill need to use variables instead of signals for the state registers dir and run . The modified MyHDL code looks as follows: from myhdl import * ACTIVE = 0 DirType = enum ( 'RIGHT' , 'LEFT' ) @block def jc2_alt ( goLeft , goRight , stop , clk , q ): \"\"\" A bi-directional 4-bit Johnson counter with stop control. I/O pins: -------- clk      : input free-running clock goLeft   : input signal to shift left (active-low switch) goRight  : input signal to shift right (active-low switch) stop     : input signal to stop counting (active-low switch) q        : 4-bit counter output (active-low LEDs; q[0] is right-most) \"\"\" @instance def logic (): dir = DirType . LEFT run = False while True : yield clk . posedge # direction if goRight == ACTIVE : dir = DirType . RIGHT run = True elif goLeft == ACTIVE : dir = DirType . LEFT run = True # stop if stop == ACTIVE : run = False # counter action if run : if dir == DirType . LEFT : q . next [ 4 : 1 ] = q [ 3 :] q . next [ 0 ] = not q [ 3 ] else : q . next [ 3 :] = q [ 4 : 1 ] q . next [ 3 ] = not q [ 0 ] return logic The instance decorator is used to create the logic generator from the\ncorresponding generator function. The main functionality of that function is\nwrapped in a while True loop to keep the generator alive \"forever\". The first\nstatement in the loop is a yield statement that specifies the sensitivity to\nthe clock edge. Variables dir and run are local state variables, that keep\ntheir previous value through each iteration of the while loop. You may wonder why we couldn't use the always decorator with a clock edge\nargument as before. The reason is that in that case, the decorated function is\na classic (= non-generator) function that would be called on every clock edge.\nHowever, local variables loose their value whenever a function returns, so they\ncannot hold state. Therefore, we need to use a more general approach and code\nthe desired behavior explicitly in a generator function. This example is more subtle and complex than it may seem at first sight. As\nsaid before, variables dir and run are state variables and will therefore\nrequire a flip-flop in an implementation. However, they are also used\n\"combinatorially\": when they change, they may influence the counter operation\n\"in the same clock cycle\", that is, before the flip-flop output changes. This\nis perfectly fine behavior and no problem for synthesis tools, but it tends to\nconfuse a lot of designers. This coding style is also a favourite theme of this\nauthor :-) ( --- Jan Decaluwe ). To verify whether we now have the desired behavior, we can run the original\ntest bench on the alternative design: Alternative design\n------------------\ngoLeft goRight stop clk q\n------------------------------\n  1      1      1    C  0000\n  1      1      1    C  0000\n  0      1      1    C  0001\n  1      1      1    C  0011\n  1      1      1    C  0111\n  1      1      1    C  1111\n  1      1      1    C  1110\n  1      1      1    C  1100\n  1      1      1    C  1000\n  1      1      1    C  0000\n  1      1      1    C  0001\n  1      1      1    C  0011\n  1      1      0    C  0011\n  1      1      1    C  0011\n  1      1      1    C  0011\n  1      0      1    C  0001\n  1      1      1    C  0000\n  1      1      1    C  1000\n  1      1      1    C  1100\n  1      1      1    C  1110\n  1      1      1    C  1111\n  1      1      1    C  0111\n  1      1      1    C  0011\n  1      1      1    C  0001\n  1      1      1    C  0000 If you compare this output with the previous one, you will see that the counter\nresponse to a control input change is now indeed one clock cycle earlier. Like before, we can convert the MyHDL code automatically to Verilog: module jc2_alt ( goLeft , goRight , stop , clk , q ); // A bi-directional 4-bit Johnson counter with stop control. // // I/O pins: // -------- // // clk      : input free-running clock // goLeft   : input signal to shift left (active-low switch) // goRight  : input signal to shift right (active-low switch) // stop     : input signal to stop counting (active-low switch) // q        : 4-bit counter output (active-low LEDs; q[0] is right-most) input goLeft ; input goRight ; input stop ; input clk ; output [ 3 : 0 ] q ; reg [ 3 : 0 ] q ; always @( posedge clk ) begin : JC2_ALT_LOGIC reg [ 1 - 1 : 0 ] dir ; reg run ; if (( goRight == 0 )) begin dir = 1 'b0 ; run = 1 'b1 ; end else if (( goLeft == 0 )) begin dir = 1 'b1 ; run = 1 'b1 ; end if (( stop == 0 )) begin run = 1 'b0 ; end if ( run ) begin if (( dir == 1 'b1 )) begin q [ 4 - 1 : 1 ] <= q [ 3 - 1 : 0 ]; q [ 0 ] <= ( ! q [ 3 ]); end else begin q [ 3 - 1 : 0 ] <= q [ 4 - 1 : 1 ]; q [ 3 ] <= ( ! q [ 0 ]); end end end endmodule Verilog's always block is more general than the MyHDL always decorator,\nbecause you cannot use local state variables with the latter. However, even\nthough the MyHDL code for the alternative design doesn't use the always decorator, the convertor is smart enough to see that it can still use it in the\nVerilog code in this case. Note that blocking and non-blocking assignments are mixed in the always block.\nThis is necessary to match the behavior of the alternative MyHDL design. In the\nVerilog world, you may encounter rules that forbid such a coding style. Such\nrules are typically created by designers that prefer to focus on \"thinking\nhardware\" instead of thinking in terms of code, even when synthesis tools are\nperfectly able to create efficient hardware from that code. The best you can do\nwith such rules is to ignore them.", 
            "title": "Johnson Counter", 
            "url": "/docs/examples/jc2.html"
        }, 
        {
            "tags": "", 
            "text": "Introduction The purpose of this example is to show how a demonstrator design that is\noriginally coded in VHDL can be done in MyHDL. The original design is here .\nBasically, it draws the message \"Hello World\" on a screen. We will show how MyHDL can make the design task easier. For example, it is not\nnecessary to worry about VHDL type conversions anymore: the MyHDL type system\ngives hardware designers exactly the right types for synthesizable code. In\nparticular, MyHDL has integers that \"just work\" instead of low level signed and unsigned types. Furthermore, we will show how MyHDL's embedded scripting\ncapabilities can be used to automate tasks that are traditionally done outside\nsynthesizable code, resulting in a clearer and less error prone design. It may be interesting to compare the original VHDL code with the code generated\nby the MyHDL convertor. Therefore, the generated VHDL and Verilog code is\nlisted also. Design decisions To demonstrate the capabilities of MyHDL, we made a number of design decisions\nthat are different from the original: We start from ascii art generated by a program instead of a table of '0's and '1's as in the original code. This makes it easier to visualize the message right in the code. We use embedded scripting to generate the desired format in-place. While we were at it, we used a nicer font :-) The whole image is set up as a table so that we can do a one-liner indexing operation in the hardware behavior description. We describe the actual hardware behavior in a sequential instead of a combinatorial process. This is a more abstract view that leads to shorter and more robust code. We introduced a row variable to make the intention clearer. MyHDL code from myhdl import * import re def HelloWorld ( pixelClock , Red , Green , Blue , hSync , vSync ): ### Image ### # From: figlet -f alphabet \" Hello World \" MSG = [ \"    H  H     l l        W     W         l    d    \" , \"    H  H     l l        W     W         l    d    \" , \"    HHHH eee l l ooo    W  W  W ooo rrr l  ddd    \" , \"    H  H e e l l o o     W W W  o o r   l d  d    \" , \"    H  H ee  l l ooo      W W   ooo r   l  ddd    \" , ] # Convert spaces, letters to 0, 1 def to_10 ( s ): \"\"\"Convert letters to 1, then spaces to 0\"\"\" s = re . sub ( r '\\w' , '1' , s ) s = re . sub ( r '\\s' , '0' , s ) return s MSG = [ to_10 ( s ) for s in MSG ] assert len ( MSG [ 1 ]) == 50 # Setup image as a concatenation of rows BORDER = '1' + '0' * 48 + '1' NULL = '0' * 50 IMAGE = [ BORDER ] + [ NULL ] + MSG + [ NULL ] * ( 37 - len ( MSG ) - 3 ) + [ BORDER ] assert len ( IMAGE ) == 37 # Convert strings to ints for use in convertible code TABLE = tuple ([ int ( s , 2 ) for s in IMAGE ]) ### Hardware behavior ### # Timing constants hMaxCount = 1056 - 1 hStartSync = 840 hEndSync = 968 vMaxCount = 628 - 1 vStartSync = 601 vEndSync = 605 # Signals hCounter = Signal ( intbv ( 0 )[ 11 :]) vCounter = Signal ( intbv ( 0 )[ 10 :]) shiftReg = Signal ( modbv ( 0 )[ 50 :]) @always_comb def assign (): v = intbv ( 0 )[ 4 :] v [ 3 ] = shiftReg [ 49 ] Red . next = v Green . next = v Blue . next = v @always ( pixelClock . posedge ) def draw (): row = intbv ( 0 )[ 6 :] if hCounter == hMaxCount : hCounter . next = 0 if vCounter == vMaxCount : vCounter . next = 0 else : row [:] = vCounter [ 10 : 4 ] shiftReg . next = TABLE [ row ] vCounter . next = vCounter + 1 else : hCounter . next = hCounter + 1 if hCounter [ 4 :] == 15 : shiftReg . next = shiftReg << 1 hSync . next = hCounter >= hStartSync and hCounter < hEndSync vSync . next = vCounter >= vStartSync and vCounter < vEndSync return assign , draw Issues This is a draft version - work in progress No simulations done yet, so there will be bugs :-) Where is the reset??? Conversion to VHDL and Verilog The MyHDL code can be converted to VHDL and Verilog\nas follows: ### Conversion to VHDL & Verilog pixelClock = Signal ( bool ( 0 )) Red = Signal ( intbv ( 0 )[ 4 :]) Green = Signal ( intbv ( 0 )[ 4 :]) Blue = Signal ( intbv ( 0 )[ 4 :]) hSync = Signal ( bool ( 0 )) vsync = Signal ( bool ( 0 )) for f in ( toVHDL , toVerilog ): f ( HelloWorld , pixelClock , Red , Green , Blue , hSync , vsync ) Generated VHDL code -- File: HelloWorld.vhd -- Generated by MyHDL 0.8dev -- Date: Thu Aug 16 17:20:37 2012 library IEEE ; use IEEE.std_logic_1164. all ; use IEEE.numeric_std. all ; use std.textio. all ; use work.pck_myhdl_08. all ; entity HelloWorld is port ( pixelClock : in std_logic ; Red : out unsigned ( 3 downto 0 ); Green : out unsigned ( 3 downto 0 ); Blue : out unsigned ( 3 downto 0 ); hSync : out std_logic ; vSync : out std_logic ); end entity HelloWorld ; architecture MyHDL of HelloWorld is signal hCounter : unsigned ( 10 downto 0 ); signal vCounter : unsigned ( 9 downto 0 ); signal shiftReg : unsigned ( 49 downto 0 ); begin HELLOWORLD_ASSIGN : process ( shiftReg ) is variable v : unsigned ( 3 downto 0 ); begin v := to_unsigned ( 0 , 4 ); v ( 3 ) := shiftReg ( 49 ); Red <= v ; Green <= v ; Blue <= v ; end process HELLOWORLD_ASSIGN ; HELLOWORLD_DRAW : process ( pixelClock ) is variable row : unsigned ( 5 downto 0 ); begin if rising_edge ( pixelClock ) then row := to_unsigned ( 0 , 6 ); if ( hCounter = 1055 ) then hCounter <= \"00000000000\" ; if ( vCounter = 627 ) then vCounter <= \"0000000000\" ; else row := vCounter ( 10 - 1 downto 4 ); case to_integer ( row ) is when 0 => shiftReg <= \"10000000000000000000000000000000000000000000000001\" ; when 1 => shiftReg <= \"00000000000000000000000000000000000000000000000000\" ; when 2 => shiftReg <= \"00001001000001010000000010000010000000001000010000\" ; when 3 => shiftReg <= \"00001001000001010000000010000010000000001000010000\" ; when 4 => shiftReg <= \"00001111011101010111000010010010111011101001110000\" ; when 5 => shiftReg <= \"00001001010101010101000001010100101010001010010000\" ; when 6 => shiftReg <= \"00001001011001010111000000101000111010001001110000\" ; when 7 => shiftReg <= \"00000000000000000000000000000000000000000000000000\" ; when 8 => shiftReg <= \"00000000000000000000000000000000000000000000000000\" ; when 9 => shiftReg <= \"00000000000000000000000000000000000000000000000000\" ; when 10 => shiftReg <= \"00000000000000000000000000000000000000000000000000\" ; when 11 => shiftReg <= \"00000000000000000000000000000000000000000000000000\" ; when 12 => shiftReg <= \"00000000000000000000000000000000000000000000000000\" ; when 13 => shiftReg <= \"00000000000000000000000000000000000000000000000000\" ; when 14 => shiftReg <= \"00000000000000000000000000000000000000000000000000\" ; when 15 => shiftReg <= \"00000000000000000000000000000000000000000000000000\" ; when 16 => shiftReg <= \"00000000000000000000000000000000000000000000000000\" ; when 17 => shiftReg <= \"00000000000000000000000000000000000000000000000000\" ; when 18 => shiftReg <= \"00000000000000000000000000000000000000000000000000\" ; when 19 => shiftReg <= \"00000000000000000000000000000000000000000000000000\" ; when 20 => shiftReg <= \"00000000000000000000000000000000000000000000000000\" ; when 21 => shiftReg <= \"00000000000000000000000000000000000000000000000000\" ; when 22 => shiftReg <= \"00000000000000000000000000000000000000000000000000\" ; when 23 => shiftReg <= \"00000000000000000000000000000000000000000000000000\" ; when 24 => shiftReg <= \"00000000000000000000000000000000000000000000000000\" ; when 25 => shiftReg <= \"00000000000000000000000000000000000000000000000000\" ; when 26 => shiftReg <= \"00000000000000000000000000000000000000000000000000\" ; when 27 => shiftReg <= \"00000000000000000000000000000000000000000000000000\" ; when 28 => shiftReg <= \"00000000000000000000000000000000000000000000000000\" ; when 29 => shiftReg <= \"00000000000000000000000000000000000000000000000000\" ; when 30 => shiftReg <= \"00000000000000000000000000000000000000000000000000\" ; when 31 => shiftReg <= \"00000000000000000000000000000000000000000000000000\" ; when 32 => shiftReg <= \"00000000000000000000000000000000000000000000000000\" ; when 33 => shiftReg <= \"00000000000000000000000000000000000000000000000000\" ; when 34 => shiftReg <= \"00000000000000000000000000000000000000000000000000\" ; when 35 => shiftReg <= \"00000000000000000000000000000000000000000000000000\" ; when others => shiftReg <= \"10000000000000000000000000000000000000000000000001\" ; end case ; vCounter <= ( vCounter + 1 ); end if ; else hCounter <= ( hCounter + 1 ); if ( hCounter ( 4 - 1 downto 0 ) = 15 ) then shiftReg <= shift_left ( shiftReg , 1 ); end if ; end if ; hSync <= stdl (( hCounter >= 840 ) and ( hCounter < 968 )); vSync <= stdl (( vCounter >= 601 ) and ( vCounter < 605 )); end if ; end process HELLOWORLD_DRAW ; end architecture MyHDL ; Generated Verilog code // File: HelloWorld.v // Generated by MyHDL 0.8dev // Date: Thu Aug 16 17:20:37 2012 `timescale 1 ns / 10 ps module HelloWorld ( pixelClock , Red , Green , Blue , hSync , vSync ); input pixelClock ; output [ 3 : 0 ] Red ; reg [ 3 : 0 ] Red ; output [ 3 : 0 ] Green ; reg [ 3 : 0 ] Green ; output [ 3 : 0 ] Blue ; reg [ 3 : 0 ] Blue ; output hSync ; reg hSync ; output vSync ; reg vSync ; reg [ 10 : 0 ] hCounter ; reg [ 9 : 0 ] vCounter ; reg [ 49 : 0 ] shiftReg ; always @( shiftReg ) begin : HELLOWORLD_ASSIGN reg [ 4 - 1 : 0 ] v ; v = 4'h0 ; v [ 3 ] = shiftReg [ 49 ]; Red = v ; Green = v ; Blue = v ; end always @( posedge pixelClock ) begin : HELLOWORLD_DRAW reg [ 6 - 1 : 0 ] row ; row = 6'h0 ; if (( hCounter == 1055 )) begin hCounter <= 0 ; if (( vCounter == 627 )) begin vCounter <= 0 ; end else begin row = vCounter [ 10 - 1 : 4 ]; case ( row ) 0 : shiftReg <= 51'h2000000000001 ; 1 : shiftReg <= 0 ; 2 : shiftReg <= 47'h241402080210 ; 3 : shiftReg <= 47'h241402080210 ; 4 : shiftReg <= 47'h3dd5c24bba70 ; 5 : shiftReg <= 47'h25554152a290 ; 6 : shiftReg <= 47'h2595c0a3a270 ; 7 : shiftReg <= 0 ; 8 : shiftReg <= 0 ; 9 : shiftReg <= 0 ; 10 : shiftReg <= 0 ; 11 : shiftReg <= 0 ; 12 : shiftReg <= 0 ; 13 : shiftReg <= 0 ; 14 : shiftReg <= 0 ; 15 : shiftReg <= 0 ; 16 : shiftReg <= 0 ; 17 : shiftReg <= 0 ; 18 : shiftReg <= 0 ; 19 : shiftReg <= 0 ; 20 : shiftReg <= 0 ; 21 : shiftReg <= 0 ; 22 : shiftReg <= 0 ; 23 : shiftReg <= 0 ; 24 : shiftReg <= 0 ; 25 : shiftReg <= 0 ; 26 : shiftReg <= 0 ; 27 : shiftReg <= 0 ; 28 : shiftReg <= 0 ; 29 : shiftReg <= 0 ; 30 : shiftReg <= 0 ; 31 : shiftReg <= 0 ; 32 : shiftReg <= 0 ; 33 : shiftReg <= 0 ; 34 : shiftReg <= 0 ; 35 : shiftReg <= 0 ; default : shiftReg <= 51'h2000000000001 ; endcase vCounter <= ( vCounter + 1 ); end end else begin hCounter <= ( hCounter + 1 ); if (( hCounter [ 4 - 1 : 0 ] == 15 )) begin shiftReg <= ( shiftReg << 1 ); end end hSync <= (( hCounter >= 840 ) && ( hCounter < 968 )); vSync <= (( vCounter >= 601 ) && ( vCounter < 605 )); end endmodule", 
            "title": "Hello World", 
            "url": "/docs/examples/helloworld.html"
        }, 
        {
            "tags": "", 
            "text": "Introduction On this page you will find a number of MyHDL descriptions of flip-flops and\nlatches. Typically, you wouldn't describe flip-flops and latches as individual modules.\nRather, they can be inferred from higher-level  RTL description by a synthesis\ntool. However, as these circuits are small and widely known, they are well\nsuited to explain basic MyHDL usage and to compare MyHDL with other solutions. D flip-flop Specification The basic D flip-flop is a sequential device that transfers the value of the d input to the q output on every rising edge of the clock clk . Description Here is the description of a D flip-flop in MyHDL: from myhdl import * @block def dff ( q , d , clk ): @always ( clk . posedge ) def logic (): q . next = d return logic Simulation Let's add a small test bench to simulate the design: from random import randrange @block def test_dff (): q , d , clk = [ Signal ( bool ( 0 )) for i in range ( 3 )] dff_inst = dff ( q , d , clk ) @always ( delay ( 10 )) def clkgen (): clk . next = not clk @always ( clk . negedge ) def stimulus (): d . next = randrange ( 2 ) return dff_inst , clkgen , stimulus def simulate ( timesteps ): simInst = test_dff () simInst . config_sim ( trace = True , tracebackup = False ) simInst . run_sim ( timesteps , quiet = 0 ) simulate ( 2000 ) Function test_dff creates an instance of the D flip-flop, and adds a clock\ngenerator and a random stimulus generator around it. Function simulate simulates the test bench. Note how the MyHDL function traceSignals is used to create the test bench instance (instead of calling test_dff directly). As a result, a signal trace file will be created during\nsimulation. This file can be inspecting in a waveform viewer. As a verification\nmethod, inspecting waveforms has its drawbacks, but it can be very effective to\ndebug small designs. Here's a screen shot of the simulation waveforms: Automatic conversion to Verilog or VHDL With MyHDL's convert function, a D flip-flop instance can be converted to\nVerilog or VHDL code: def convert (): q , d , clk = [ Signal ( bool ( 0 )) for i in range ( 3 )] convInst = dff ( q , d , clk ) #, 'Verilog') convInst . convert ( hdl = 'Verilog' ) convInst . convert ( hdl = 'VHDL' ) convert () This is the resulting Verilog code: module dff ( q , d , clk ); output q ; reg q ; input d ; input clk ; always @( posedge clk ) begin : DFF_LOGIC q <= d ; end endmodule D flip-flop with asynchronous reset Specification One of the most useful sequential building blocks is a D flip-flop with an\nadditional asynchronous reset pin. When the reset is not active, it operates as\na basic D flip-flop as in the previous section. When the reset pin is active,\nthe output is held to zero. Typically, the reset pin is active low. Description Here is the description: from myhdl import * @block def dffa ( q , d , clk , rst ): @always_seq ( clk . posedge , reset = rst ) def logic (): if rst == 0 : # nRst ?  or use active high ? q . next = 0 else : q . next = d return logic Simulation Here is a test bench for the design: from random import randrange @block def test_dffa (): q , d , clk = [ Signal ( bool ( 0 )) for i in range ( 3 )] rst = ResetSignal ( val = 1 , active = 0 , isasync = True ) dffa_inst01 = dffa ( q , d , clk , rst ) @always ( delay ( 10 )) def clkgen (): clk . next = not clk @always ( clk . negedge ) def stimulus (): d . next = randrange ( 2 ) @instance def rstgen (): yield delay ( 5 ) rst . next = 1 while True : yield delay ( randrange ( 500 , 1000 )) rst . next = 0 yield delay ( randrange ( 80 , 140 )) rst . next = 1 return dffa_inst , clkgen , stimulus , rstgen def simulate ( timesteps ): simInst = test_dffa () simInst . config_sim ( trace = True , tracebackup = False ) simInst . run_sim ( timesteps , quiet = 0 ) simulate ( 2000 ) Compared to the test bench for the basic D flip-flop, there is an additional\nreset generator, that generates reset pulses at random moments and with a\nrandom duration. Here is a screen shot of the waveforms: Automatic conversion to Verilog or VHDL The design can be converted to Verilog and VHDL: def convert (): q , d , clk = [ Signal ( bool ( 0 )) for i in range ( 3 )] rst = ResetSignal ( val = 1 , active = 0 , isasync = True ) convInst = dffa ( q , d , clk , rst ) convInst . convert ( hdl = 'Verilog' ) convInst . convert ( hdl = 'VHDL' ) convert () The VHDL result looks like this: entity dffa is port ( q : out std_logic ; d : in std_logic ; clk : in std_logic ; rst : in std_logic ); end entity dffa ; architecture MyHDL of dffa is begin DFFA_LOGIC : process ( clk , rst ) is begin if ( rst = '0' ) then q <= '0' ; elsif rising_edge ( clk ) then if ( rst = '0' ) then q <= '0' ; else q <= d ; end if ; end if ; end process DFFA_LOGIC ; end architecture MyHDL ; Latch Specification A basic latch is a sequential device with an input, and output and a control\ngate pin. When the gate is open, the output follows the input combinatorially.\nWhen it is closed, the output keeps its value. Description The following code describes a latch: from myhdl import * @block def latch ( q , d , g ): @always_comb def logic (): if g == 1 : q . next = d return logic Note the usage of the always_comb decorator. This is somewhat of a misnomer.\n(The name comes from a similar construct in SystemVerilog). It doesn't mean the\ngenerator describes a circuit that is necessarily combinatorial, but merely\nthat it triggers whenever one of the input signals changes. Simulation Here is a test bench to simulate the latch: from random import randrange @block def test_latch (): q , d , g = [ Signal ( bool ( 0 )) for i in range ( 3 )] latch_inst = latch ( q , d , g ) @always ( delay ( 7 )) def dgen (): d . next = randrange ( 2 ) @always ( delay ( 41 )) def ggen (): g . next = randrange ( 2 ) return latch_inst , dgen , ggen def simulate ( timesteps ): simInst = test_latch () simInst . config_sim ( trace = True ) simInst . run_sim ( timesteps , quiet = 0 ) simulate ( 2000 ) In addition to the latch instance, the test bench creates a random data\ngenerator for the input and for the controlling gate. Here is a screen shot of the simulation waveforms: Automatic conversion to Verilog or VHDL We can convert the design as follows: def convert (): q , d , g = [ Signal ( bool ( 0 )) for i in range ( 3 )] convInst = latch ( q , d , g ) convInst . convert ( hdl = 'Verilog' ) convInst . convert ( hdl = 'VHDL' ) convert () Here is the verilog result: module latch ( q , d , g ); output q ; reg q ; input d ; input g ; always @( g , d ) begin : LATCH_LOGIC if (( g == 1 )) begin q = d ; end end endmodule Note that when the toVerilog function converts the always_comb decorator,\nit infers which signals are used as inputs to the always block", 
            "title": "Flip-flops and Latches", 
            "url": "/docs/examples/flipflops.html"
        }, 
        {
            "tags": "", 
            "text": "", 
            "title": "Examples", 
            "url": "/docs/examples/index.html"
        }, 
        {
            "tags": "", 
            "text": "Introduction On this page we will present the design of a sine and cosine computer. Specification We will assume that the input angle is represented in radians, and that it is\nin the range between -π/2 and π/2 . Other angles can be handled by adding a\nfactor π first (modulo 2π ) and changing the sign of the sine and cosine\nresult. The floating point numbers are represented as integers. Technically, this means\nrounding them to a fixed number of bits, and then multiplying them with the\nfactor 2**F , where F is the number of bits after the point. Both the sine and the cosine of the input angle will be computed. The interface\nof the module looks as follows: def SineComputer ( cos_z0 , sin_z0 , done , z0 , start , clock , reset ): \"\"\" Sine and cosine computer. This module computes the sine and cosine of an input angle. The floating point numbers are represented as integers by scaling them up with a factor corresponding to the number of bits after the point. Ports: ----- cos_z0: cosine of the input angle sin_z0: sine of the input angle done: output flag indicating completion of the computation z0: input angle; -pi/2 <= z0 <= pi/2 start: input that starts the computation on a posedge clock: clock input reset: reset input \"\"\" Unit test We will first write a unit test for the design. The idea is to use the cos and sin functions from the math module to compute the expected results on a\nnumber of input angles, and to compare them with the outputs from the design\nunder test. Here is the code: from math import pi , sin , cos , log import random from myhdl import * from SineComputer import SineComputer , SineComputer_v def bench ( fractionSize , errorMargin , nrTests = 100 ): \"\"\" Test bench for SineComputer. fractionSize: number of bits after the point errorMargin: margin for rounding errors on result nrTests: number of tests vectors \"\"\" # scaling factor to represent floats as integers M = 2 ** fractionSize # maximum angle ZMAX = int ( round ( M * pi / 2 )) # error margin shorthand D = errorMargin # signals cos_z0 = Signal ( intbv ( 0 , min =- D , max = M + D )) sin_z0 = Signal ( intbv ( 0 , min =- M - D , max = M + D )) z0 = Signal ( intbv ( 0 , min =- ZMAX , max = ZMAX + 1 )) done = Signal ( False ) start = Signal ( False ) clock = Signal ( bool ( 0 )) reset = Signal ( True ) # design under test dut = SineComputer ( cos_z0 , sin_z0 , done , z0 , start , clock , reset ) # clock generator @always ( delay ( 10 )) def clockgen (): clock . next = not clock # test vector setup testAngles = [ - pi / 2 , - pi / 4 , 0.0 , pi / 4 , pi / 2 ] testAngles . extend ([ random . uniform ( - pi / 2 , pi / 2 ) for i in range ( nrTests )]) # actual test @instance def check (): yield clock . negedge reset . next = False for z in testAngles : yield clock . negedge z0 . next = int ( round ( M * z )) start . next = True yield clock . negedge start . next = False yield done . posedge exp_cos_z0 = int ( round ( cos ( z ) * M )) exp_sin_z0 = int ( round ( sin ( z ) * M )) assert abs ( cos_z0 - exp_cos_z0 ) < D assert abs ( sin_z0 - exp_sin_z0 ) < D raise StopSimulation return dut , clockgen , check As the design will perform its calculations in finite precision, there will be\nrounding errors. Therefore, the comparisons between expected and actual results\nare performed using an error margin. We may want to use the test bench for\ndesigns with different characteristics; therefore, the error margin is made a\nparameter. The precision is specified in terms of the number of bits after the point,\nusing the parameter fractionSize . To represent the numbers, we use the intbv class, which is basically an\ninteger-like type with bit-vector capabilities. Note that we constrain the intbv instances by specifying the range of valid integer values, not by a bit\nwidth. For high-level, algorithmic work, this is much easier. Moreover, it\nenables fine-grained range error checking at run-time. By filling in the parameters of the bench function, we can construct an\nactual test bench that runs a simulation, as follows: def test_bench (): fractionSize = 18 errorMargin = fractionSize tb = bench ( fractionSize , errorMargin ) sim = Simulation ( tb ) sim . run () A function with a name starting with test_ is automatically recognized and run by a unit testing framework such as py.test . Algorithm To implement the design, we will use the Cordic algorithm, a very popular\nalgorithm to compute trigonometric functions in hardware. On this page, we are\nmainly interested in the mechanical characteristics of the algorithm and their\nhardware implications. For more information and background on the algorithm\nitself, please consult other sources, such as this paper by Ray\nAndraka . The Cordic algorithm is an iterative algorithm based on vector rotations over\nelementary angles. The algorithm normally operates in one of two modes. In\nrotation mode, it rotates a vector (x 0 , y 0 ) in the\nCartesian plane over an input angle z 0 . The Cordic equations for\nthis mode are: x i +1 = x i - y i d i 2 -i y i +1 = y i - x i d i 2 -i z i +1 = y i - d i tan -i (2 -i ) where d i = -1 if z i < 0, else +1. These equations can be implemented with relatively simple hardware. This is the\ncharacteristic that makes the Cordic algorithm attractive. In particular,\nmultiplications with a factor 2 -i are simply shift-right operations.\nAlso, the arctangent values tan -i (2 -i ) can be precomputed\nand stored in a small look-up table. The Cordic equations can be used for a variety of computations. For our\npurposes, it can be shown that x n = cos z 0 y n = sin z 0 for the following initial conditions: x 0 = 1 / A n y 0 = 0 where A n = Product[ sqrt(1 + 2 -2i ) ] with i = 0 ... n-1 Design The Cordic algorithm can be implemented in many ways, with various\ncharacteristics and advantages. On this page, we will implement a parallel,\niterative processor, which is a fairly straightforward mapping of the equations\ninto a bit-parallel data path and a state machine. from math import atan , sqrt , ceil , floor , pi from myhdl import * t_State = enum ( \"WAITING\" , \"CALCULATING\" ) def SineComputer ( cos_z0 , sin_z0 , done , z0 , start , clock , reset ): \"\"\" Sine and cosine computer. This module computes the sine and cosine of an input angle. The floating point numbers are represented as integers by scaling them up with a factor corresponding to the number of bits after the point. Ports: ----- cos_z0: cosine of the input angle sin_z0: sine of the input angle done: output flag indicated completion of the computation z0: input angle start: input that starts the computation on a posedge clock: clock input reset: reset input \"\"\" # angle input bit width W = len ( z0 ) # angle input z0 represents number between -pi/2 and pi/2 # scaling factor corresponds to the nr of bits after the point M = 2 ** ( W - 2 ) # nr of iterations equals nr of significant input bits N = W - 1 # calculate X0 An = 1.0 for i in range ( N ): An *= ( sqrt ( 1 + 2 ** ( - 2 * i ))) # X0 X0 = int ( round ( M * 1 / An )) # tuple with elementary angles angles = tuple ([ int ( round ( M * atan ( 2 ** ( - i )))) for i in range ( N )]) # iterative cordic processor @instance def processor (): x = intbv ( 0 , min = sin_z0 . min , max = sin_z0 . max ) y = intbv ( 0 , min = sin_z0 . min , max = sin_z0 . max ) z = intbv ( 0 , min = z0 . min , max = z0 . max ) dx = intbv ( 0 , min = sin_z0 . min , max = sin_z0 . max ) dy = intbv ( 0 , min = sin_z0 . min , max = sin_z0 . max ) dz = intbv ( 0 , min = z0 . min , max = z0 . max ) i = intbv ( 0 , min = 0 , max = N ) state = t_State . WAITING while True : yield clock . posedge , reset . posedge if reset : state = t_State . WAITING cos_z0 . next = 1 sin_z0 . next = 0 done . next = False x [:] = 0 y [:] = 0 z [:] = 0 i [:] = 0 else : if state == t_State . WAITING : if start : x [:] = X0 y [:] = 0 z [:] = z0 i [:] = 0 done . next = False state = t_State . CALCULATING elif state == t_State . CALCULATING : dx [:] = y >> i dy [:] = x >> i dz [:] = angles [ int ( i )] if ( z >= 0 ): x -= dx y += dy z -= dz else : x += dx y -= dy z += dz if i == N - 1 : cos_z0 . next = x sin_z0 . next = y state = t_State . WAITING done . next = True else : i += 1 return processor The actual computation is done by the processor generator. Note that outside\nthe generator function, we calculate some data such as the X0 constant, and\nthe look-up table of elementary arctangents, represented by the angles tuple. The internal number variables are represented by intbv instances. The dual\nnature of this class comes in very handy. On the one hand, we can constrain the\ninstances as integer subtypes by specifying the valid integer range at\nconstruction time. On the other hand, we can access their two's complement\nrepresentation as a bit vector, for example for slicing or right-shifting. It seems obvious that a type that unifies the integer and the bit vector views\nshould be very useful for hardware design. One would therefore expect a similar\nfeature in other HDLs. However, I believe that it is actually a unique\ncapability offered by MyHDL. Other HDLs seem to try to solve the issues by\ncreating more and more integer and bit-vector like types. In MyHDL, a single\ntype does it all - the intbv class. py.test confirms that this is a valid impementation: > py.test\ntesting-mode: inprocess\nexecutable:   /usr/local/bin/python  (2.4.2-final-0)\nusing py lib: /usr/local/lib/python2.4/site-packages/py <rev unknown>\n\ntest_SineComputer.py[1] . Automatic conversion to Verilog Now that we have a working design (and only now!) we can attempt to convert it\nto Verilog automatically. In MyHDL, this is done by using the toVerilog function. For example, consider the instantiation of the design under test in\nthe test bench: # design under test dut = SineComputer ( cos_z0 , sin_z0 , done , z0 , start , clock , reset ) To convert the design instance to Verilog, this line can be replaced by the following: # design under test dut = toVerilog ( SineComputer , cos_z0 , sin_z0 , done , z0 , start , clock , reset ) As before, the dut object is a simulatable design instance, but as a side\neffect of the instantiation, an equivalent Verilog module file will be\ngenerated. The Verilog output is as follows: module SineComputer ( cos_z0 , sin_z0 , done , z0 , start , clock , reset ); output signed [ 19 : 0 ] cos_z0 ; reg signed [ 19 : 0 ] cos_z0 ; output signed [ 19 : 0 ] sin_z0 ; reg signed [ 19 : 0 ] sin_z0 ; output done ; reg done ; input signed [ 19 : 0 ] z0 ; input start ; input clock ; input reset ; always @( posedge clock or posedge reset ) begin : _SineComputer_processor reg [ 5 - 1 : 0 ] i ; reg [ 1 - 1 : 0 ] state ; reg signed [ 20 - 1 : 0 ] dz ; reg signed [ 20 - 1 : 0 ] dx ; reg signed [ 20 - 1 : 0 ] dy ; reg signed [ 20 - 1 : 0 ] y ; reg signed [ 20 - 1 : 0 ] x ; reg signed [ 20 - 1 : 0 ] z ; if ( reset ) begin state = 1 'b0 ; cos_z0 <= 1 ; sin_z0 <= 0 ; done <= 0 ; x = 0 ; y = 0 ; z = 0 ; i = 0 ; end else begin // synthesis parallel_case full_case casez ( state ) 1 'b0 : begin if ( start ) begin x = 159188 ; y = 0 ; z = z0 ; i = 0 ; done <= 0 ; state = 1 'b1 ; end end 1 'b1 : begin dx = $signed ( y >>> $signed ({ 1 'b0 , i })); dy = $signed ( x >>> $signed ({ 1 'b0 , i })); // synthesis parallel_case full_case case ( i ) 0 : dz = 205887 ; 1 : dz = 121542 ; 2 : dz = 64220 ; 3 : dz = 32599 ; 4 : dz = 16363 ; 5 : dz = 8189 ; 6 : dz = 4096 ; 7 : dz = 2048 ; 8 : dz = 1024 ; 9 : dz = 512 ; 10 : dz = 256 ; 11 : dz = 128 ; 12 : dz = 64 ; 13 : dz = 32 ; 14 : dz = 16 ; 15 : dz = 8 ; 16 : dz = 4 ; 17 : dz = 2 ; default : dz = 1 ; endcase if (( z >= 0 )) begin x = x - dx ; y = y + dy ; z = z - dz ; end else begin x = x + dx ; y = y - dy ; z = z + dz ; end if (( i == ( 19 - 1 ))) begin cos_z0 <= x ; sin_z0 <= y ; state = 1 'b0 ; done <= 1 ; end else begin i = i + 1 ; end end endcase end end endmodule A discussion about some convertor features With this example, some interesting features of the Verilog convertor can be\nillustrated. Taking advantage of the elaboration phase It is important to realize that the conversion occurs on a design instance .\nThis means that the code has already been elaborated by the Python\ninterpreter. Therefore, the convertor works on the simulatable data structure,\nwhich is a (hierarchical) list of generators. This means that only the source\ncode of generator functions is converted. The pleasant consequence is that the\nrestrictions of the \"convertible subset\" apply only to the code inside\ngenerator functions, not to any code outside them. For example, consider how the look-up table of elementary arctangents is set up\nin the SineComputer design: # tuple with elementary angles angles = tuple ([ int ( round ( M * atan ( 2 ** ( - i )))) for i in range ( N )]) This line uses things like a list comprehension and a call to the trigonometric\nfunction atan from the math library, At this point, this is beyond the\nscope of the convertible subset, and it may stay like that forever. But as this\ncode is outside a generator function, it doesn't matter. Inside the processor function, the lookup-up table is used as follows: z [:] = angles [ int ( i )] This is just fine for the convertor. Note how this single-line lookup is\nexpanded into a case statement in the Verilog output. Note that we have been talking about the convertible subset, and not about the\n\"synthesizable subset\". The reason is that the convertible subset is much less\nrestrictive. You can find more information about the convertible subset in the\nMyHDL manual. Obviously, MyHDL code intended for synthesis also has to take synthesis-related\nrestrictions into account. But again, these restrictions only apply to the code\ninside generator functions, because only that code is actually converted. The described behavior is a unique feature of the MyHDL design flow. Outside\ngenerator functions, you can use Python's full power to describe designs. As\nlong as the code inside them obeys the constraints of the convertible subset,\nthe design instance can always be converted to Verilog. And if that code also\nobeys the constraints of the synthesizable subset, the result will be\nsynthesizable Verilog. Handling negative numbers One important feature of the convertor is that it handles the details of signed\nand unsigned representations automatically. When writing synthesizable code, a\nMyHDL designer can use a high-level view for integer operations by using the intbv type, and rely on the underlying two's complement representation to do\nthe right thing automatically. In contrast, a Verilog designer is forced to\ndeal with low-level representational issues explicitly. This can become very\ntricky, especially with negative numbers and the signed representation. First of all, note in the Verilog output that the convertor infers which\nvariables have to be declared as signed . This is the easy part. Now consider the following line in the MyHDL code of SineComputer : dx [:] = y >> i I believe it's quite clear what this is supposed to do. With the underlying\ntwo's complement representation, it works for positive and negative values of y . Now consider how this has been translated into Verilog: dx = $signed ( y >>> $signed ({ 1 'b0 , i })); The convertor has to deal with several potential pitfalls. The fundamental\nproblem is that Verilog uses an unsigned interpretation by default, which is\nthe opposite from what you should do to get the naturally expected results. First, the convertor uses arithmetic shift ( >>> ) instead of bit-wise shift\n( >> ), to have the sign bit shifted in instead of a zero. Secondly, the second (unsigned) operand is typecasted to $signed , after\nadding a sign bit. Otherwise, Verilog will interprete all operands in a mixed\nexpression as unsigned. Having said that, the Verilog literature seems to\nindicate that a shift operation is an exception to this rule. But the convertor\ndoesn't take risks and inserts the typecast as a general measure. It may be\nredundant in this case. Finally, the whole expression is typecasted to $signed . Actually, I would\nhave expected that this typecast would not be necessary - after all, we are\nshifting a signed number. However, my current simulator (Cver) tells me that it\nis. It may be wrong, I don't know. Anyway, the cast is an additional safety\nnet. The message you should get from this discussion is the following: working with\nthe signed representation in Verilog is tricky. I believe that writing the code\nin a natural, high-level way in MyHDL, and letting the convertor take care of\nthe low-level representation issues, is a better option. (Of course, we still\nneed to make sure that the convertor gets it right, which is hard enough.) Verilog co-simulation Clearly we will want to verify that the Verilog output from the convertor is\ncorrect. For this purpose, MyHDL supports co-simulation with Verilog. To set up a co-simulation, we need to create a Cosimulation object for the\nVerilog design. The Verilog convertor makes this task easier. In addition to\nthe Verilog code for the design itself, it also generates a Verilog test bench\nstub that defines an interface between the Verilog design and a Cosimulation\nobject. The following function creates a Cosimulation object for our design: def SineComputer_v ( cos_z0 , sin_z0 , done , z0 , start , clock , reset ): toVerilog ( SineComputer , cos_z0 , sin_z0 , done , z0 , start , clock , reset ) cmd = \"cver -q +loadvpi=myhdl_vpi:vpi_compat_bootstrap \" + \\ \"SineComputer.v tb_SineComputer.v\" return Cosimulation ( cmd , ** locals ()) We start by doing the Verilog conversion itself first. Then, we define the\ncommand to start up the Verilog simulator. This is of course\nsimulator-specific. The command shown is for the open-source Cver simulator. It\nloads a vpi module that defines the interface between the MyHDL simulator and\nthe Verilog simulator. Also, both the Verilog code for the design and the test\nbench stub are compiled. The Cosimulation object is then constructed with the command as its first\nparameter, followed by a number of keyword arguments. The keyword arguments\nmake the link between signal names declared in the Verilog test bench stub and\nsignals in the MyHDL code. When the signal names in MyHDL and Verilog are\nidentical we can use a little trick and simply pass the local namespace\ndictionary locals() to the constructor. In the test bench code, we replace the instantiation of the MyHDL module with\nthis function: dut = SineComputer_v ( cos_z0 , sin_z0 , done , z0 , start , clock , reset ) When running py.test again, we now run a co-simulation between the MyHDL test\nbench and the Verilog code: testing-mode: inprocess\nexecutable:   /usr/local/bin/python  (2.4.2-final-0)\nusing py lib: /usr/local/lib/python2.4/site-packages/py <rev unknown>\n\ntest_SineComputer.py[1] Copyright (c) 1991-2005 Pragmatic C Software Corp.\n  All Rights reserved.  Licensed under the GNU General Public License (GPL).\n  See the 'COPYING' file for details.  NO WARRANTY provided. So the test bench confirms that the Verilog code is correct. Historical note When this example was developed with MyHDL 0.5, this test\nfailed, showing that the convertor had bugs. It turned out that the handling of\nsigned variables with shift operations had not been implemented and tested\nproperly. Therefore, this example has been the trigger to fix these bugs and\ndevelop MyHDL 0.5.1. Implementation To confirm synthesizablity, this example was synthesized with Xilinx ISE and\ntargeted to a Spartan FPGA. For detailed information, you can review the synthesis report .", 
            "title": "Cordic-based Sine Computer", 
            "url": "/docs/examples/sinecomp/index.html"
        }, 
        {
            "tags": "", 
            "text": "Introduction On this page, we will present a stopwatch design. It is similar to the design\nin the Xilinx ISE tutorial . We\nwill tackle it \"the MyHDL way\" and take it from spec to implementation. This is an extensive example, and we will use it to present all aspects of a\nMyHDL-based design flow. It's also a relatively advanced. If you have\ndifficulties understanding the material on this page, consider reading the\nfirst chapters of the manual or the\nearlier examples in this Cookbook first. Specification Compared to the design in the Xilinx ISE tutorial, our design is somewhat\nsimplified. The intention is not to avoid complexity, but merely to make the\ncode and the explanations better fit on a single web page. In particular, our\nstopwatch will only have three digits: two digits for the seconds, and one for\nthe tenths of a second. Also, we will not consider clock generation issues and\nsimply assume that a 10Hz clock is available. The interface of the stopwatch design looks as follows: @block def StopWatch ( tens_led , ones_led , tenths_led , startstop , reset , clock ): \"\"\" 3 digit stopwatch with seconds and tenths of a second. tens_led: 7 segment led for most significant digit of the seconds ones_led: 7 segment led for least significant digit of the seconds tenths_led: 7 segment led for tenths of a second startstop: input that starts or stops the stopwatch on a posedge reset: reset input clock: 10Hz clock input \"\"\" Architecture A stopwatch system is naturally partitioned as follows: a subsystem that counts time, expressed as digits in bcd (binary coded decimal) code a subsystem that displays the count, by converting each bcd digit to a 7 segment led display A natural partitioning often works best, and that's how we will approach the\ndesign. We will first design a  time counter and then a bcd to led convertor. Time counter design Approach One of the goals of the MyHDL project is to promote the use of modern software\ndevelopment techniques for hardware design. One such technique is the concept\nof unit testing, a cornerstone of extreme programming (XP). Unit testing means writing a dedicated test for each building block of a\ndesign, and aggregating all tests in a regression test suite using a unit test\nframework. Moreover, the XP idea is to write the unit test first , before the\nactual implementation. This makes sure that the test writer concentrates on all\naspects of the high level specification, without being influenced by lower\nlevel implementation details. At the start of an implementation, the existing unit test will fail, and it\nwill continue to do so until a valid implementation is achieved. The unit test\nthus serves as a metric for completion. Moreover, to see the unit test fail on\nincomplete or invalid designs enhances the confidence in the test quality\nitself. This is of crucial importance when making design changes later on. Unit test To write a unit test for building block, we need two things: the specification\nand the interface. The specification was described in previous sections. The\ninterface of the time counter looks as follows: from myhdl import * def TimeCount ( tens , ones , tenths , startstop , reset , clock ): \"\"\" 3 digit time counter in seconds and tenths of a second. tens: most significant digit of the seconds ones: least significant digit of the seconds tenths: tenths of a second startstop: input that starts or stops the counter on a posedge reset: reset input clock: 10Hz clock input \"\"\" The actual implementation is left open for now. We will first write the test, using the interface. The following code is the unit test for the time counter subsystem in file test_TimeCount.py : from random import randrange from myhdl import * from TimeCount import TimeCount LOW , HIGH = bool ( 0 ), bool ( 1 ) MAX_COUNT = 6 * 10 * 10 PERIOD = 10 @block def bench (): \"\"\" Unit test for time counter. \"\"\" tens , ones , tenths = [ Signal ( intbv ( 0 )[ 4 :]) for i in range ( 3 )] startstop , reset , clock = [ Signal ( LOW ) for i in range ( 3 )] dut = TimeCount ( tens , ones , tenths , startstop , reset , clock ) count = Signal ( 0 ) counting = Signal ( False ) @always ( delay ( PERIOD // 2 )) def clkgen (): clock . next = not clock @always ( startstop . posedge , reset . posedge ) def action (): if reset : counting . next = False count . next = 0 else : counting . next = not counting @always ( clock . posedge ) def counter (): if counting : count . next = ( count + 1 ) % MAX_COUNT @always ( clock . negedge ) def monitor (): assert (( tens * 100 ) + ( ones * 10 ) + tenths ) == count @instance def stimulus (): for maxInterval in ( 100 * PERIOD , 2 * MAX_COUNT * PERIOD ): for sig in ( reset , startstop , reset , startstop , startstop , reset , startstop , startstop , startstop , reset , startstop , reset , startstop , startstop , startstop ): yield delay ( randrange ( 10 * PERIOD , maxInterval )) yield clock . negedge # sync to avoid race condition sig . next = HIGH yield delay ( 100 ) sig . next = LOW raise StopSimulation return dut , clkgen , action , counter , monitor , stimulus def test_bench (): sim = Simulation ( bench ()) sim . run () dut is the design under test. clkgen is a clock generator. action defines\nthe stopwatch state, based on a rising edge on either of the input signals startstop or reset . counter maintains the expected time count. monitor is the actual test: it asserts that the actual time count from the design\nequals the expected time count. Finally, stimulus defines a number of test\ncases for the stopwatch. Note that it has an inner for loop over signals, as\na concise way to define test patterns. This is straightforward in Python. But\nthink for a moment on how you would do it in Verilog or VHDL. Also in stimulus , note the yield clock.negedge statement. This statement\nsynchronizes signal changes with the falling clock edge. This is needed to\navoid race conditions when signals change \"simultaneously\" with the rising\nclock edge. This is commonly done in digital tests. As you can expect, this\nstatement was not present in the first version of the test: it was added after\nthe test was run against the implementation and found to fail occasionally,\neven when the implementation was believed to be correct. This shows that in\npractice there may be a good reason why a test needs to be adapted to get\neverything working. But it in any case it is better to start with a \"general\"\nunit test that is not influenced by an implementation. Our unit test is now ready to run. We could actually run it directly against an\nimplementation. However, we will use it via the unit testing framework py.test instead. The framework provides the following functionality: it redefines the Python assert statement for extensive error reporting it looks up and runs each method whose name starts with \"test_\" it looks up test modules by searching for modules whose name starts with \"test_\" There's a lot more to say about py.test and you are probably also curious\nwhere to get it from. You can find that info further on this page, in the\nsection More about py.test . Design The following is an implementation of the time counter, in file TimeCount.py : from myhdl import * @block def TimeCount ( tens , ones , tenths , startstop , reset , clock ): \"\"\" 3 digit time counter in seconds and tenths of a second. tens: most significant digit of the seconds ones: least significant digit of the seconds tenths: tenths of a second startstop: input that starts or stops the counter on a posedge reset: reset input clock: 10kHz clock input \"\"\" @instance def logic (): seen = False counting = False while True : yield clock . posedge , reset . posedge if reset : tens . next = 0 ones . next = 0 tenths . next = 0 seen = False counting = False else : if startstop and not seen : seen = True counting = not counting elif not startstop : seen = False if counting : if tenths == 9 : tenths . next = 0 if ones == 9 : ones . next = 0 if tens == 5 : tens . next = 0 else : tens . next = tens + 1 else : ones . next = ones + 1 else : tenths . next = tenths + 1 return logic py.test confirms that this is a valid implementation: $ py.test test_TimeCount.py\n============================= test session starts ==============================\nplatform linux -- Python 3.7.3, pytest-7.1.1, pluggy-1.0.0\nrootdir: /home/jan/tmp/projects/myhdl/myhdl.org/work/testing-examples-code/stopwatch\ncollected 1 item                                                               \n\ntest_TimeCount.py .                                                      [100%]\n\n============================== 1 passed in 0.68s =============================== bcd to led convertor design Approach For the design of the bcd to led convertor , we will follow a similar approach\nas before. We will write a unit test first, and then use it to complete the\ndesign. We first put the encoding data in a separate module, seven_segment.py , to\nmake it reusable. The appropriate data structure for the encoding is a\ndictionary: # 7 segment encoding #      0 #     --- #  5 |   | 1 #     ---   <- 6 #  4 |   | 2 #     --- #      3 encoding = { 0 : \"1000000\" , 1 : \"1111001\" , 2 : \"0100100\" , 3 : \"0110000\" , 4 : \"0011001\" , 5 : \"0010010\" , 6 : \"0000010\" , 7 : \"1111000\" , 8 : \"0000000\" , 9 : \"0010000\" } Unit test This is the unit test, in test_bcd2led.py : from random import randrange import seven_segment from myhdl import * from bcd2led import bcd2led PERIOD = 10 @block def bench (): led = Signal ( intbv ( 0 )[ 7 :]) bcd = Signal ( intbv ( 0 )[ 4 :]) clock = Signal ( bool ( 0 )) dut = bcd2led ( led , bcd , clock ) @always ( delay ( PERIOD // 2 )) def clkgen (): clock . next = not clock @instance def check (): for i in range ( 100 ): bcd . next = randrange ( 10 ) yield clock . posedge yield clock . negedge expected = int ( seven_segment . encoding [ int ( bcd )], 2 ) assert led == expected raise StopSimulation return dut , clkgen , check def test_bench (): sim = Simulation ( bench ()) sim . run () This test asserts that the led output from the design matches the appropriate\nencoding for a digit. Design Here is an implementation, in bcd2led.py : import seven_segment from myhdl import * code = [ None ] * 10 for key , val in seven_segment . encoding . items (): if 0 <= key <= 9 : code [ key ] = int ( val , 2 ) code = tuple ( code ) @block def bcd2led ( led , bcd , clock ): \"\"\" bcd to seven segment led convertor. led: seven segment led output bcd: bcd input clock: clock input \"\"\" @always ( clock . posedge ) def logic (): led . next = code [ int ( bcd )] return logic Note how we derive the tuple code from the encoding dictionary. We need a\ntuple because that's the data structure that the Verilog convertor supports.\nIt maps tuple indexing to a case statement to support ROM inferencing by\nsynthesis tools. When we run py.test , we get the following output: $ py.test\n============================= test process starts ==============================\nplatform linux -- Python 3.7.3, pytest-7.1.1, pluggy-1.0.0\nrootdir: /.../testing-examples-code/stopwatch\ncollected 2 items                                                              \n\ntest_TimeCount.py .                                                      [ 50%]\ntest_bcd2led.py .                                                        [100%]\n\n============================== 2 passed in 0.53s =============================== Note that when run with no arguments, py.test finds and runs all test\nmodules. This is done recursively through all subdirectories, making it\nstraightforward to run a full regression test suite. Top level design The top-level design in StopWatch.py is just an assembly of the previously\ndesigned modules: from myhdl import * from TimeCount import TimeCount from bcd2led import bcd2led @block def StopWatch ( tens_led , ones_led , tenths_led , startstop , reset , clock ): \"\"\" 3 digit stopwatch with seconds and tenths of a second. tens_led: 7 segment led for most significant digit of the seconds ones_led: 7 segment led for least significant digit of the seconds tenths_led: 7 segment led for tenths of a second startstop: input that starts or stops the stopwatch on a posedge reset: reset input clock: 10Hz clock input \"\"\" tens , ones , tenths = [ Signal ( intbv ( 0 )[ 4 :]) for i in range ( 3 )] timecount_inst = TimeCount ( tens , ones , tenths , startstop , reset , clock ) bcd2led_tens = bcd2led ( tens_led , tens , clock ) bcd2led_ones = bcd2led ( ones_led , ones , clock ) bcd2led_tenths = bcd2led ( tenths_led , tenths , clock ) return timecount_inst , bcd2led_tens , bcd2led_ones , bcd2led_tenths Implementation Automatic conversion to Verilog or VHDL To go to an implementation, we first convert the design to Verilog\nautomatically, using MyHDL's toVerilog function: def convert (): tens_led , ones_led , tenths_led = [ Signal ( intbv ( 0 )[ 7 :]) for i in range ( 3 )] startstop , reset , clock = [ Signal ( bool ( 0 )) for i in range ( 3 )] convInst = StopWatch ( tens_led , ones_led , tenths_led , startstop , reset , clock ) convInst . convert ( hdl = 'Verilog' ) convInst . convert ( hdl = 'VHDL' ) convert () The resulting Verilog code is included in full: module StopWatch ( tens_led , ones_led , tenths_led , startstop , reset , clock ); output [ 6 : 0 ] tens_led ; reg [ 6 : 0 ] tens_led ; output [ 6 : 0 ] ones_led ; reg [ 6 : 0 ] ones_led ; output [ 6 : 0 ] tenths_led ; reg [ 6 : 0 ] tenths_led ; input startstop ; input reset ; input clock ; reg [ 3 : 0 ] ones ; reg [ 3 : 0 ] tens ; reg [ 3 : 0 ] tenths ; always @( posedge clock , posedge reset ) begin : STOPWATCH_TIMECOUNT0_LOGIC reg seen ; reg counting ; if ( reset ) begin tens <= 0 ; ones <= 0 ; tenths <= 0 ; seen = 1 'b0 ; counting = 1 'b0 ; end else begin if (( startstop && ( ! seen ))) begin seen = 1 'b1 ; counting = ( ! counting ); end else if (( ! startstop )) begin seen = 1 'b0 ; end if ( counting ) begin if (( tenths == 9 )) begin tenths <= 0 ; if (( ones == 9 )) begin ones <= 0 ; if (( tens == 5 )) begin tens <= 0 ; end else begin tens <= ( tens + 1 ); end end else begin ones <= ( ones + 1 ); end end else begin tenths <= ( tenths + 1 ); end end end end always @( posedge clock ) begin : STOPWATCH_BCD2LED0_LOGIC case ( tens ) 0 : tens_led <= 64 ; 1 : tens_led <= 121 ; 2 : tens_led <= 36 ; 3 : tens_led <= 48 ; 4 : tens_led <= 25 ; 5 : tens_led <= 18 ; 6 : tens_led <= 2 ; 7 : tens_led <= 120 ; 8 : tens_led <= 0 ; default : tens_led <= 16 ; endcase end always @( posedge clock ) begin : STOPWATCH_BCD2LED1_LOGIC case ( ones ) 0 : ones_led <= 64 ; 1 : ones_led <= 121 ; 2 : ones_led <= 36 ; 3 : ones_led <= 48 ; 4 : ones_led <= 25 ; 5 : ones_led <= 18 ; 6 : ones_led <= 2 ; 7 : ones_led <= 120 ; 8 : ones_led <= 0 ; default : ones_led <= 16 ; endcase end always @( posedge clock ) begin : STOPWATCH_BCD2LED2_LOGIC case ( tenths ) 0 : tenths_led <= 64 ; 1 : tenths_led <= 121 ; 2 : tenths_led <= 36 ; 3 : tenths_led <= 48 ; 4 : tenths_led <= 25 ; 5 : tenths_led <= 18 ; 6 : tenths_led <= 2 ; 7 : tenths_led <= 120 ; 8 : tenths_led <= 0 ; default : tenths_led <= 16 ; endcase end endmodule Note how the Verilog convertor expands the hierarchical design into a \"flat net\nlist of always blocks\". The Verilog ouput is really an intermediate step\ntowards an implementation. The whole design is flat and contained in a single\nfile, which may make it easier to hand it off to back-end synthesis and\nimplementation tools. Note also how the convertor expands tuple indexing in MyHDL into a case\nstatement in Verilog. Synthesis We will synthesize the design with Xilinx ISE 8.1. We first create a project in\nthe ISE environment, add the source of the Verilog file to it, and we are ready\nto go. The following is extracted from the synthesis report. It shows how the\nsynthesis tool recognizes higher-level functions such as ROMs and counters: =========================================================================\n*                           HDL Synthesis                               *\n=========================================================================\n\nSynthesizing Unit <StopWatch>.\n    Related source file is \"/home/jand/dev/myhdl/example/cookbook/stopwatch/StopWatch.v\".\n    Found 16x7-bit ROM for signal <$n0007> created at line 68.\n    Found 16x7-bit ROM for signal <$n0008> created at line 84.\n    Found 16x7-bit ROM for signal <$n0009> created at line 100.\n    Found 7-bit register for signal <tenths_led>.\n    Found 7-bit register for signal <ones_led>.\n    Found 7-bit register for signal <tens_led>.\n    Found 1-bit register for signal <_StopWatch_timecount_inst_logic/counting>.\n    Found 1-bit register for signal <_StopWatch_timecount_inst_logic/seen>.\n    Found 4-bit up counter for signal <ones>.\n    Found 4-bit up counter for signal <tens>.\n    Found 4-bit up counter for signal <tenths>.\n    Summary:\n    inferred   3 ROM(s).\n    inferred   3 Counter(s).\n    inferred  23 D-type flip-flop(s).\nUnit <StopWatch> synthesized. How these blocks are actually implemented depends on the target technology and\nthe capabilities of the synthesis tool. You can review the full FPGA synthesis report here . FPGA implementation The FPGA implementation report can be reviewed here . CPLD implementation The same design was also targetted to a CPLD technology. The detailed report\ncan be viewed here . More about py.test To verify the stopwatch design, we have been using py.test . However, this is\nnot the only unit testing framework available for Python. In fact, the standard\nunit testing framework that comes with Python is the unittest module. The unittest framework is presented in the MyHDL manual, and is used to verify\nMyHDL itself. On the other hand, py.test is not part of the standard Python\nlibrary currently. Why then did we use py.test in this case? The reason is that I believe that py.test will be a better option in the\nfuture. As demonstrated on this page, py.test is non-intrusive. The only\nthing we need to do for basic usage is to obey some simple naming conventions\nand to use the assert statement for testing - things we might want to do\nwithout a testing framework anyway.  In contrast, unittest requires us to\nwrap our tests into dedicated subclasses and to use special test methods. This\ncan be especially awkward with MyHDL, because MyHDL hardware is typically\ndescribed using top-level and embedded functions, not classes and methods. In short, it is much easier to develop unit tests with py.test than it is\nwith unittest , in particular in the case of MyHDL code. However, py.test also has its disadvantages: As py.test is not part of the standard Python library, it has to be\ninstalled separately. py.test is currently not distributed in a convential way such as a tar\nfile. It is part of the py.lib library that has to be checked out from a\nsubversion repository. This requires the installation of a subversion client. The use of the assert statement for unit testing is controversial in\nPython. The assert statement is originally intended for programmer usage,\nto make programs safer. However, in my opinion the use of assert for\ntesting is natural and warranted. py.test uses a lot of \"magic\" behind the scenes to modify Python's behavior\nfor its purposes, such as extensive error reporting. However, I believe that the benefits are far more important than the\ndisadvantages. Moreover, some disadvantages may disappear over time.\nConsequently, I plan to promote py.test as the unit testing framework of\nchoice for MyHDL in the future. More info on the usage and installation of py.test can be found here .", 
            "title": "StopWatch", 
            "url": "/docs/examples/stopwatch/index.html"
        }, 
        {
            "tags": "", 
            "text": "Introduction This page focusses on the possibilities to describe hardware structure in\nMyHDL. MyHDL uses classic functions for this purpose. Before simulation or conversion to Verilog, a design is elaborated by running\nthe Python interpreter. This implies that all structure is flattened out. As a\nconsequence, the complexity of the structural description has no impact on the\npossibility to convert to Verilog or VHDL. As an example, this page shows how to describe recursive structures in MyHDL.\nPython is very well suited to do this elegantly. But after conversion to\nVerilog, all recursion is flattened out, so it doesn't matter whether the\nback-end language or tools support it or not. Specification We will develop a circuit that sorts an array of integer values. More\nspecifically, the array to be sorted is the input, and the sorted array the\noutput. We are looking for a data-flow oriented circuit, where the output\nfollows the input \"combinatorially\". We will use the bitonic sort algorithm. We will not explain it here: for more\ninfo, read this web page that explains the bitonic sort\nalgorithm . For our purposes, it is sufficient to know that the bitonic algorithm is well\nsuited for a hardware implementation, and that it is recursive in nature. To\ndevelop the MyHDL code, we will start from a reference software implementation. Reference implementation in Java The web page mentioned earlier also contains an annotated reference implementation in Java.\nWe will use this as a starting point to develop the MyHDL code. Therefore, the\noriginal Java code and annotations are quoted literally in the remainder of\nthis section. (start quote) In the following, an implementation of bitonic sort in Java is given. The number of elements to be sorted must be a power of 2. The program is assumed to be encapsulated in a class with the following elements: private static int[] a;         // the array to be sorted\nprivate final static boolean ASCENDING=true, DESCENDING=false; // sorting direction A comparator is modelled by the procedure compare , where the parameter dir indicates the sorting direction. If dir is ASCENDING and a[i] > a[j] is\ntrue or dir is DESCENDING and a[i] > a[j] is false then a[i] and a[j] are interchanged. private static void compare(int i, int j, boolean dir)\n{\n    if (dir==(a[i]>a[j]))\n    {\n        int h=a[i];\n        a[i]=a[j];\n        a[j]=h;\n    }\n} The procedure bitonicMerge recursively sorts a bitonic sequence in ascending\norder, if dir = ASCENDING , and in descending order otherwise. The sequence to\nbe sorted starts at index position lo , the number of elements is n . private static void bitonicMerge(int lo, int n, boolean dir)\n{\n    if (n>1)\n    {\n        int k=n/2;\n        for (int i=lo; i<lo+k; i++)\n            compare(i, i+k, dir);\n        bitonicMerge(lo, k, dir);\n        bitonicMerge(lo+k, k, dir);\n    }\n} Procedure bitonicSort first produces a bitonic sequence by recursively\nsorting its two halves in opposite directions, and then calls bitonicMerge . private static void bitonicSort(int lo, int n, boolean dir)\n{\n    if (n>1)\n    {\n        int k=n/2;\n        bitonicSort(lo, k, ASCENDING);\n        bitonicSort(lo+k, k, DESCENDING);\n        bitonicMerge(lo, n, dir);\n    }\n} When called with parameters lo = 0 , n = a.length() and dir = ASCENDING ,\nprocedure bitonicSort sorts the whole array a . public static void sort()\n{\n    bitonicSort(0, a.length(), ASCENDING);\n} (end quote) MyHDL implementation Let's start with some general considerations. First, note that the Java code consists of a number of procedures and procedure\ncalls. In MyHDL, we can map each procedure to a function that models a hardware\nmodule and each procedure call to an instantiation. The Java procedures return\nnothing; they are run solely for their side effects. In MyHDL, we will build\nthe hardware structure by returning the instances that compose each module. Secondly, note that the Java code sorts the array in-place, and the procedure\nparameters consist of the indices of the array elements to be manipulated. In\nour data-flow oriented MyHDL solution, we will have to use a separate input and\noutput array instead. The array will be represented by a list of signals. If a\nfunction performs several transformations, we have to introduce additional\nlists of signals internally. Finally, in the Java code the recursion stops by \"doing nothing\". In the MyHDL\ncode, the equivalent is to assign the input to the output signal. We will need\na \"feedthrough\" circuit for this purpose. Now we are ready to fill in the details, in the same order as in the original\nJava version. We start by importing the myhdl library, and by defining some boolean\nconstants: from myhdl import * DESCENDING , ASCENDING = False , True The compare leaf module is a combinatorial circuit with two input and two\noutput signals. By default, the inputs are \"fed through\" to the outputs, but\nunder the same condition as in the Java code, they are interchanged: def compare ( a1 , a2 , z1 , z2 , dir ): @always_comb def logic (): z1 . next = a1 z2 . next = a2 if dir == ( a1 > a2 ): z1 . next = a2 z2 . next = a1 return logic As mentioned, we will also need a feedthrough circuit, the equivalent of \"doing\nnothing\" in the Java code: def feedthru ( a , z ): @always_comb def logic (): z . next = a return logic Function bitonicMerge describes a higher-level module that takes a list of\nsignals as its input and its output. Instead of manipulating array elements\nbased on indices as in Java, it generates the output from the input list of\nsignals. Note how an additional list of signals is introduced in the case of n > 1 , and how the recursion stops with a feedthru instance. def bitonicMerge ( a , z , dir ): n = len ( a ) k = n // 2 w = len ( a [ 0 ]) if n > 1 : t = [ Signal ( intbv ( 0 )[ w :]) for i in range ( n )] comp = [ compare ( a [ i ], a [ i + k ], t [ i ], t [ i + k ], dir ) for i in range ( k )] loMerge = bitonicMerge ( t [: k ], z [: k ], dir ) hiMerge = bitonicMerge ( t [ k :], z [ k :], dir ) return comp , loMerge , hiMerge else : feed = feedthru ( a [ 0 ], z [ 0 ]) return feed Function bitonicSort is written in a similar fashion: def bitonicSort ( a , z , dir ): n = len ( a ) k = n // 2 w = len ( a [ 0 ]) if n > 1 : t = [ Signal ( intbv ( 0 )[ w :]) for i in range ( n )] loSort = bitonicSort ( a [: k ], t [: k ], ASCENDING ) hiSort = bitonicSort ( a [ k :], t [ k :], DESCENDING ) merge = bitonicMerge ( t , z , dir ) return loSort , hiSort , merge else : feed = feedthru ( a [ 0 ], z [ 0 ]) return feed Now we can define a top level module, for example to sort an array of 8 values.\nThere is a slight restriction however. The Verilog convertor cannot handle\nlists of signals in a top level interface. (This is related to the fact that\nVerilog memories cannot be used as ports.) To make the design suited for\nconversion, we have to splice the lists into individual signals: def Array8Sorter ( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , z0 , z1 , z2 , z3 , z4 , z5 , z6 , z7 ): a = [ a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 ] z = [ z0 , z1 , z2 , z3 , z4 , z5 , z6 , z7 ] sort = bitonicSort ( a , z , ASCENDING ) return sort Verification Verifying the sorter design is easy enough. We set up a list of random data\nvalues, assign it to the inputs of the circuit, then sort the data list and\ncompare it with the outputs. from random import randrange from myhdl import * from bitonic import Array8Sorter def bench (): n = 8 w = 4 a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 = inputs = \\ [ Signal ( intbv ( 0 )[ w :]) for i in range ( n )] z0 , z1 , z2 , z3 , z4 , z5 , z6 , z7 = outputs = \\ [ Signal ( intbv ( 0 )[ w :]) for i in range ( n )] inst = Array8Sorter ( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , z0 , z1 , z2 , z3 , z4 , z5 , z6 , z7 ) @instance def check (): for i in range ( 100 ): data = [ randrange ( 2 ** w ) for i in range ( n )] for i in range ( n ): inputs [ i ] . next = data [ i ] yield delay ( 10 ) data . sort () assert data == outputs return inst , check def test_bench (): sim = Simulation ( bench ()) sim . run () This test bench can be used with a unit test framework such as py.test . Verilog generation and synthesis The sorter design can be converted to Verilog as usual, with the toVerilog function. See the Verilog code for the result. Note that it is a\n\"net list of always blocks\", with all structure and recursion flattened out. Of course, you will want to verify that the generated Verilog code is correct.\nThis can be done by using Verilog co-simulation with the same test bench as\nused for the MyHDL code. You can find the details about the procedure here . To get an idea of the hardware implementation characteristics, check out the synthesis results .", 
            "title": "Bitonic Sort", 
            "url": "/docs/examples/bitonic/index.html"
        }
    ]
}